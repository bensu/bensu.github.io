<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>sbensu: How to avoid API breaking changes</title>
    
<meta name="keywords" content="">

<meta name="description" content="When writing graphical user interfaces, the end user is a person. If the user interface changes overnight, the user might be surprised but they can adapt and react accordingly. Most software companies are used to changing their products often in various ways. API products don’t have this luxury.APIs are used by programs which can’t adapt to change. So, whenever you change an API, the change should be backwards compatible so that the new API version can be used by existing integrations.  For a list of breaking changes one can make to JSON APIs, see Breaking changes in JSON APIs.">

<meta property="og:description" content="When writing graphical user interfaces, the end user is a person. If the user interface changes overnight, the user might be surprised but they can adapt and react accordingly. Most software companies are used to changing their products often in various ways. API products don’t have this luxury.APIs are used by programs which can’t adapt to change. So, whenever you change an API, the change should be backwards compatible so that the new API version can be used by existing integrations.  For a list of breaking changes one can make to JSON APIs, see Breaking changes in JSON APIs.">

<meta property="og:url" content="https://blog.sbensu.com/posts/2023-03-16-api-avoid-breaking-changes/" />
<meta property="og:title" content="How to avoid API breaking changes" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://blog.sbensu.com/posts/2023-03-16-api-avoid-breaking-changes/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar navbar-default">
    <div class="container nav-container">
        <div class="vertical-container">
            <div class="nav-inner-container">
              <a class="top-link" href="/">sbensu/</a>
              <div>
                  <span>sbensu@gmail.com • </span>
                  <a href="https://twitter.com/sebasbensu">@sebasbensu</a>
              </div>
            </div>
        </div>
    </div>
</nav>

<div class="container">
    <div class="row">
        <div class="col-lg-12">
            <div id="content">
                
<div id="post">
    <div class="post-header">
    <h2>How to avoid API breaking changes</h2>
    <div id="post-meta" class="row">
        <div class="col-lg-6">March 16, 2023</div>
        
    </div>
</div>
<div>
    <p>When writing graphical user interfaces, the end user is a person. If the user interface changes overnight, the user might be surprised but they can adapt and react accordingly. Most software companies are used to changing their products often in various ways. API products don’t have this luxury.</p><p>APIs are used by programs which can’t adapt to change. So, whenever you change an API, the change should be <em>backwards compatible</em> so that the new API version can be used by existing integrations.  For a list of breaking changes one can make to JSON APIs, see <a href="/posts/2023-03-16-api-breaking-changes/">Breaking changes in JSON APIs</a>.</p><p>In other words, certain decisions are much harder to reverse than others. This changes how API products are developed: when it comes to APIs, it is much higher to ship fast and iterate. And in many cases you can’t really iterate.</p><h1 id="hyrum’s_law">Hyrum’s law</h1><p>From <a href="https://www.hyrumslaw.com/">Hyrum’s law</a> which has (and deserves!) its own website:</p><blockquote><p> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody. </p></blockquote><p>In other words, your API “leaks” promises of how it will behave. For these “hidden” promises, you should define an explicit contract and track those changes as backwards-incompatible. Otherwise, you risk breaking your users' integrations without realizing. There are probably domain-specific "promises" that apply to your API that I can’t cover in this essay. Think about them as you design your API. Here are some hidden promises that a payment API might make:</p><ul><li><strong>Settlement speed</strong>: Money will be available at certain times in certain accounts. In test mode, the payment might clear into the developer’s balance immediately. But in live mode, it would take 5 minutes for the balance to be there because it was handled by some queue. The integration may assume that clearing is immediate because it was immediate during testing. Stripe’s ACH v1 had this problem.</li><li><strong>FX quote expiry</strong>: If someone wants to convert USD to EUR, your API gives them a quote that defines a rate between the two. That quote is available until an expiry time, for example "next 30 minutes". If you shorten that time, integrations that rely on having 30 minutes to react to the quote will break.</li><li><strong>Dynamic properties</strong>: If a property like <code>description</code> is dynamically generated from other data, like <code>{{PRODUCT}} ${{AMOUNT}}</code>, developers will parse out <code>PRODUCT</code> and <code>AMOUNT</code> from it. Later, when you change how <code>description</code> is generated and add <code>QUANTITY</code> to the string, you might break their parsing logic. This also applies to error messages.</li><li><strong>Async properties</strong>: Returning a property asynchronously when it was previously returned synchronously is a breaking change. An example from invoices:<ul><li>In certain jurisdictions there are strict rules on how invoice numbers should be generated. Imagine that in the first version of the API you return the invoice number synchronously when the invoice <em>draft</em> is created. But that causes problems and out of compliance. To be compliant, you start generating the invoice number asynchronously. Existing integrations depend on having that invoice number on creation and thus are broken by the change.</li></ul></li><li><strong>Field length</strong>: If you return short of ids with a fixed length (e.g. <code>ch_123456</code>), users will assume that they will continue to be short and of a fixed length and store them in their database with <code>varchar(16)</code>. If you ever start returning longer ids (i.e. larger than 16 characters), they won’t fit in your user’s database and break their integration.</li></ul><p>I don’t have a good recipe to figure out what these are, but as Hyrum’s law suggests, they will surprise you and <em>they will happen.</em></p><p>On top of that, all APIs are making non-functional promises: Many of them surprising:</p><ul><li><strong>Latency</strong>: if they always return within 200ms, developers will assume that they will continue to return within 200ms. Making the API respond within 1000ms may break an integration which times out at 500ms.</li><li><strong>Price</strong>: if today it costs $0.01 per call, a developer might design their integration one way, and if you change the price, it may “break” that integration</li><li><strong>Throughput:</strong> a threaded integration might break if you reduce the rate limits that throttle the allowed requests per second.</li><li><strong>Storage:</strong> if you store an object for the developer, you just promised that you would store it forever unless there is a specific eviction policy<a href="#fn-1" id="fnref1"><sup>1</sup></a>.</li><li><strong>Reliability:</strong> This is often an explicit part of the SLA.</li><li><strong>Consistency:</strong> Do integrations expect to read an object after they write it? Most APIs work this way but if you ever relax that and allow caches (which may be stale) to return certain calls, you will break integrations.</li></ul><h2 id="if_everything_you_do_might_bring_you_problems,_*do_less*">If everything you do might bring you problems, <em>do less</em></h2><p>As Hyrum’s suggests, the more you do, the more mistakes you can make. And because APIs are forever<a href="#fn-2" id="fnref2"><sup>2</sup></a>, mistakes are forever too. The best way to make fewer mistakes is to do less overall. </p><p>So, if when considering a feature you <em>wonder</em> “will they need it?”, then don’t add it. Wait until enough people complain about it before you add it. This way you will be sure they needed it. You don’t want to add surface area that you may regret unless it is really worth it.</p><p>For example, let’s say that your API could have a number of side-effects (store something in a database, emit an event to some other service, send an email, etc). Once you add those side-effects, you can’t really remove them. But you can always add them later under some parameter like <code>send_email</code>. When in doubt, do less.</p><p>Restrict your instinct to be helpful. For example, don’t volunteer information in the API responses that the developer doesn’t absolutely need. For example, Stripe originally added <code>count</code> on list endpoints because Mongo returned it from the list queries. It turns out that Mongo struggles to calculate that <code>count</code> as collections grow, and it creates all sorts of performance problems. It is not super clear that Stripe users need <code>count</code>. For that and other reasons, list endpoints are some of the worst endpoints for Stripe to maintain.</p><p>What should’ve early Stripe done? You might think “Ahh, they shouldn’t have added <code>count</code> if nobody asked for it”. No, <em>Stripe shouldn’t have offered list endpoints until absolutely necessary<a href="#fn-3" id="fnref3"><sup>3</sup></a>.</em> Behind every user request for a list endpoint lurks a specific problem to be solved that could be better solved in some other way:</p><ul><li><strong>Reconciliation:</strong> “I want to reconcile my payments to the cash in bank account“<ul><li>If there are lots of payments, a list endpoint will be a moving target: as you list payments to add them up, new ones payments and changes come in, making it impossible for you to get a true snapshot of what happened in the period.</li><li>This is better served by immutable reports that can be reconciled against bank statements.</li></ul></li><li><strong>Customer portal:</strong> “I want to show customers their payments in my app”<ul><li>List endpoints have high latency and customers have to wait a long time for their page to render.</li><li>The integration should store its notion of orders in their database, and when displaying each individual order, fetch the associated payment from Stripe. Alternatively, Stripe could make a <a href="https://stripe.com/docs/customer-management">Customer Portal</a>.</li></ul></li><li><strong>Metrics:</strong> “I want to calculate how much revenue I made each day / month / period”<ul><li>It takes forever to send all the payments over the network each time you want to calculate the metrics.</li><li>It is better for the integration to store the changes as they come in their own data warehouse and then calculate metrics based on that warehouse. Alternatively, they could use the Stripe dashboard or <a href="https://stripe.com/sigma">Sigma</a>.</li></ul></li><li><strong>Search:</strong> “I want to search through the latest payments for one with certain metadata”<ul><li>The list endpoint will return fresh data (read-after-write) but it will be a very inefficient way to search for one payment.</li><li>This is better served by a search API (e.g. <code>/search?metadata[key]=value</code>) that has all the needed indexes and can return only the objects that the user needs. (The flip-side is that a search API powered by Elastic Search is likely going to return data that is a few minutes stale which may or may not be fine for the user)</li></ul></li></ul><p>But once integrations depend on list endpoints, Stripe can never retire them.</p><h1 id="product_development_for_apis">Product development for APIs</h1><p>So how do you evolve your product if you can’t change it often or do A/B tests<a href="#fn-4" id="fnref4"><sup>4</sup></a>? You need to find other ways to test changes. Here is one recipe:</p><ol><li>Talk to developers before designing the APIs</li><li>Test the APIs internally and maintain real integrations</li><li>Release in alpha to external developers, subject to change</li><li>Watch them integrate</li><li>Revise the API several times while in alpha</li><li>Consider the far future when designing</li></ol><h2 id="(1)_talk_to_developers_before_designing_the_apis">(1) Talk to developers before designing the APIs</h2><p>Unlike consumers, developers have to think quite a bit before using an API. Before sitting down and writing a program, they have to consider how the API integrates with what they are building. After they do that, they will form strong opinions regarding what they need for their use-case and they’ll discover new requirements as they code the integration.</p><p>This means that it is much easier to interview a developer about their needs than a consumer.</p><p>For example, businesses want to be paid at different times:</p><ol><li>One business wants to be paid right away so that they in turn can pay their suppliers.</li><li>The other business wants to get the money 5 days later once they fulfill goods, so that the cash accounting is aligned with the revenue accounting.</li></ol><p>When interviewing businesses, it is important to understand <em>why</em> they need what they need. For the settlement timing example above, you may be tempted to add a <code>payment_delay</code> parameter:</p><ol><li>One user can pass <code>payment_delay: 0</code> (days) and get their money right away.</li><li>The other one can pass <code>payment_delay: 5</code> (days) and get their money 5 days later.</li></ol><p>But that would’ve been a mistake. The second business fulfills 5 days later <em>on average.</em> They don’t know when they will fulfill the goods in advance. The right parameter would’ve been:</p><ol><li><code>settlement_on: capture</code>  to get the money right away.</li><li><code>settlement_on: fulfillment</code> to get the money later, once they hit a new fulfillment API.</li></ol><p>By understanding why developers want what they want you can (to some extent) predict other things they will want and make their lives easier in the future.</p><h2 id="(2)_test_the_apis_internally_and_maintain_real_integrations">(2) Test the APIs internally and maintain real integrations</h2><p>Once you understand what developers want, you can pretend to be them and then use your API. Ask your coworkers to test the API. (You should also test it but their testing will be a much more reliable way to find problems)</p><p>Ask everybody to write friction logs as they test the API. Friction logs are what they sound like: a log that details every moment when the developer encountered some friction. Include screenshots and code snippets of what was confusing alongside what you were thinking when it happened.</p><p>There is something very fragile about evaluating APIs (and products in general): once you understand how they work, you are no longer a reliable proxy for a new user. There are all sorts of friction and problems that can only be found by fresh eyes. For example, the word <code>account</code> is often ambiguous to new users but well-defined to those who learned it. Therefore, you should weigh the feedback from those fresh eyes heavily: they are seeing things that every new developer will see but you are now blind to.</p><p>Ideally, you can maintain a real integration and see its problems over time. In Stripe’s case, this meant having a small side-business to sell things online. A few Stripe employees did this and had great ideas for improving the product<a href="#fn-5" id="fnref5"><sup>5</sup></a>.</p><h2 id="(3)_release_an_alpha_subject_to_change">(3) Release an alpha subject to change</h2><p>Interviews and internal testing will only get you so far. Developers will discover requirements as they integrate and importantly, <em>way after</em> they integrate. Their support team might discover that your API behaves in unexpectedly when support tickets come in. This alpha period lets you change things more fluidly with the expectation that if you do change the API, the alpha integrations will be updated.</p><p>Even if they agree to upgrading eventually, alpha users will drag their feet when you ask them to upgrade. Keep this in mind as you plan deprecation timelines for the alpha.</p><h2 id="(4)_watch_everybody_integrate">(4) Watch everybody integrate</h2><p>Many of the problems from an API are subtle confusions. Some examples: </p><ol><li>The developer interprets <code>balance</code> as "pending balance" because that is what they care about when you mean "captured balance".</li><li>The developer expects the next step in their integration to be about fulfilling goods but your guide’s next step is about reconciling payments with orders.</li><li>The developer is providing services and your guide talks exclusively about selling goods which confuses them: is this guide for me?</li></ol><p>If the API ends up working for them after they resolve the confusion, they might not tell you what they struggled with. So, here are some ways to observe that process:</p><ol><li>Literally watch them. Go to their office and sit next to them while they program. Start a zoom meeting and be in the background in case they have questions. Make a Slack channel with them and ask them how they are doing every so often.</li><li>Interview them right after they’ve integrated when they are likely to still remember the problems they encountered.</li><li>Ask them to write a friction log (described above) as they integrate that you can read later. This is hard work so expect only your friends to do it.</li></ol><h2 id="(5)_revise_the_api_with_the_feedback">(5) Revise the API with the feedback</h2><p>As you revise the alpha API with users' feedback, try to make those fixes backwards compatible. This will save the alpha users some work. But if you need to, don’t be shy about making breaking changes to existing alpha integrations. This is the only time you can fix your mistakes, use it!</p><h2 id="(6)_consider_the_far_future_when_designing">(6) Consider the far future when designing</h2><p>After real usage, you’ll learn a lot more about what developers want from your API. What else might they want? What other parts of their business did they talk about? How might your API relate to those? What are some features that they mentioned but didn’t want yet?</p><p>You don’t have time to fully design all of those but keep them in mind. As the example above suggest, learning that businesses care about settlement timing and fulfillment should make you ask questions like:</p><ul><li>Do they fulfill different parts of the order at different times? If so, do they want the different parts of the payment to be captured at different times? How could you handle that if needed?<ul><li>This might make you change the signature of the <code>/fulfill</code> endpoint or ask them to pass more data about what they are fulfilling.</li></ul></li><li>Do they ever cancel fulfillments? What should happen to the resulting cash?<ul><li>This might make you consider fulfillments as a separate object with a state that has to be tracked as opposed to a single property on a payment.</li></ul></li></ul><h1 id="final_warning">Final warning</h1><p>This essay has a loose recipe for improving an API design while minimizing future breaking changes. Even with a recipe, backwards compatibility makes iterating on APIs much harder than iterating on UIs. As such, you should extend your timelines when planning the design and rollout of an API.</p><p>And you should start the process knowing that you’ll make some irreversible mistakes. Maintaining APIs is not for perfectionists.</p><h2></h2><p><em>Thanks to Remi Jannel and Michelle Bu for reading drafts and providing feedback. Also, thanks to Adam D’Angelo for providing the prompt for the essay.</em></p><h2></h2><h1 id="footnotes">Footnotes</h1><ol class="footnotes"><li id="fn-1">This is particularly dangerous if you charge per “transaction” (ie API call) but your costs are proportional to the storage <em>of all</em> transaction costs <em>every month forever</em>. As your backlog of stored transactions grows, as some point your daily flux of transactions won’t be enough revenue to cover the costs.<a href="#fnref1">↩</a></li><li id="fn-2">This is not strictly true. You can deprecate APIs but users always hate it, it is a lot of work, and hard to do well. For most minor and medium mistakes, it will not be worth the effort.<a href="#fnref2">↩</a></li><li id="fn-3">I was not around when list endpoints were introduced and what I know I learned from others. From what I understand, it seems that the best compromise would’ve been to introduce the list endpoint with relax consistency guarantees so that they could be cheaply served from caches. Most of the list endpoint use-cases don’t require the read-after-write consistency that list endpoints offer today.<a href="#fnref3">↩</a></li><li id="fn-4">There are many other reasons you can’t do A/B tests: what if one developer gets the documentation in the A variant and the Stack Overflow answer is from the B variant? Imagine how confusing that would be.<a href="#fnref4">↩</a></li><li id="fn-5">Many Stripe employees had been users of the product before joining and they also had a good understanding of the API's problems.<a href="#fnref5">↩</a></li></ol>
</div>


    <div id="prev-next">
        
        
        <a class="right" href="/posts/2023-03-16-api-breaking-changes/">Breaking changes in JSON APIs &raquo;</a>
        
    </div>
</div>

            </div>
        </div>
    </div>
</div>

<footer></footer>

<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
<script src="/js/highlight.pack.js" type="application/javascript"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
 
ga('create', 'UA-66101645-1', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>
