<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>sbensu: Breaking changes in JSON APIs</title>
    
<meta name="keywords" content="Misc,Software,Management">

<meta name="description" content="A collection of common breaking changes to JSON APIs for you to keep in mind as you design.">

<meta property="og:description" content="A collection of common breaking changes to JSON APIs for you to keep in mind as you design.">

<meta property="og:url" content="https://blog.sbensu.com/posts/api-breaking-changes/" />
<meta property="og:title" content="Breaking changes in JSON APIs" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://blog.sbensu.com/posts/api-breaking-changes/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar navbar-default">
    <div class="container nav-container">
        <div class="vertical-container">
            <div class="nav-inner-container">
              <a class="top-link" href="/">index/</a>
              <div>
                  <span>sbensu@gmail.com • </span>
                  <a href="https://twitter.com/sebasbensu">@sebasbensu</a>
              </div>
            </div>
        </div>
    </div>
</nav>

<div class="container">
    <div class="row">
        <div class="col-lg-12">
            <div id="content">
                
<div id="post">
    <div class="post-header">
    <h2>Breaking changes in JSON APIs</h2>
    <div id="post-meta" class="row">
        <div class="col-lg-6">March 2023</div>
        
    </div>
</div>
<div>
    <p>For an overall product development strategy, see <a href="/posts/api-avoid-breaking-changes/">How to avoid breaking APIs</a>.</p><p>When writing graphical user interfaces, the end user is a person. If the user interface changes overnight, the user might be surprised but they can adapt and react accordingly. Most software companies are used to changing their products often in various ways. API products don’t have this luxury.</p><p>APIs are used by programs which can’t adapt to change. So, whenever you change an API, the change should be <em>backwards compatible</em> so that the new API version can be used by existing integrations. As you make changes, you constantly need to keep track of this distinction:</p><h4 id="backwards-compatible_changes">Backwards-compatible changes</h4><ul><li>Changes you can roll out to existing integrations without causing problems for them.</li><li>For example, adding new endpoints or accepting new parameters for existing endpoints.</li></ul><h4 id="breaking_changes">Breaking changes</h4><ul><li>These are changes that might break existing integrations so you can’t simply roll them out.</li><li>To roll them out, you need to either ask all your existing integrations to migrate or you need to create a new version of the API so that new users get the change and old users don’t.</li><li>For example, if you remove a property from an endpoints response, integrations that use that property will start throwing exceptions.</li></ul><p>Here is a list of the different breaking changes one can make to an API and some advice to deal with it. It is mostly based on what I learned working with the Stripe API, so the examples are very Stripe-centric, and applies to JSON REST APIs<a href="#fn-1" id="fnref1"><sup>1</sup></a>. If you have complementary examples from other APIs, please email them to me.</p><h1 id="backwards-compatible_changes">Backwards-compatible changes</h1><p>These are the <a href="https://stripe.com/docs/upgrades#what-changes-does-stripe-consider-to-be-backwards-compatible">changes that Stripe considers as backwards-compatible</a>:</p><ul><li>Adding new API resources.</li><li>Adding new optional request parameters to existing API methods.</li><li>Adding new properties to existing API responses.</li><li>Changing the order of properties in existing API responses.</li><li>Changing the length or format of opaque strings, such as object IDs, error messages, and other human-readable strings.<ul><li>This includes adding or removing fixed prefixes (such as <code>ch_</code> on charge IDs).</li><li>You can safely assume object IDs we generate will never exceed 255 characters, but you should be able to handle IDs of up to that length. If for example you’re using MySQL, you should store IDs in a <code>VARCHAR(255) COLLATE utf8_bin</code> column (the <code>COLLATE</code> configuration ensures case-sensitivity in lookups).</li></ul></li><li>Adding new event types.<ul><li>Your webhook listener should gracefully handle unfamiliar event types.</li></ul></li></ul><p>Be careful if your proposed change is not in this list, there is probably a good reason for it.</p><p>This list makes a set of assumptions about how clients integrate with the Stripe API. For example, “Adding new properties to existing API responses” could be either backwards compatible or a breaking-change depending on how the client is integrated. Here are two Java examples, one backwards compatible and one not:</p><pre><code class="java">// We are trying to deserialize this response from the Stripe API
String json = "{id: 1, amount: 1000}";

// the naive way to use Jackson is to define a class:
public class PaymentIntent {
  public String id;
}
// and then read the string:
PaymentIntent pi = objectMapper.readValue(json, PaymentIntent.class);

// but then, the API responses comes with a new property, amount
String json = "{id: 1, amount: 1000}";

// The code above starts throwing because amount is not in PaymentIntent
PaymentIntent pi = objectMapper.readValue(json, PaymentIntent.class);

// By adding this annotation, new properties are ignored
@JsonIgnoreProperties(ignoreUnknown = true)
public class PaymentIntent {
  public String id;
}

// and this now works
PaymentIntent pi = objectMapper.readValue(json, PaymentIntent.class);
</code></pre><p>For every one of those backwards compatible changes, there is some way to integrate that would make them breaking. </p><p>Some changes are backwards-compatible for certain ecosystems but not others. For example, it is possible for “Make a required parameter optional” be backwards compatible:</p><ul><li>Languages that don't check types at runtime (ex: JS, Python, Ruby, PHP) can simply accept <code>null</code> or <code>nil</code> for the optional parameter. As long as the SDK doesn't have runtime asserts to check for the presence of that parameter, making the parameter optional is something that you can roll out overnight and the existing SDKs can accommodate.</li><li>But for staticall-typed languages (like Java, Go, .NET, Haskell, or OCaml) you have to be more careful. SDKs in those languages usually check that all the right values are passed or use <code>Maybe</code> or <code>Optional</code> for optional parameters. So, making a required parameter optional would change the type signature of the SDK (ex: <code>String</code> → <code>Optional&lt;String&gt;</code>), triggering compiler errors for anybody that upgrades the SDK<a href="#fn-2" id="fnref2"><sup>2</sup></a>. To avoid this problem, Stripe uses the <a href="https://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a> in its typed SDKs (Java, Go, .NET).</li></ul><p>To read how Stripe rolls out backwards-compatible changes without having to maintain separate code paths for each version, read this <a href="https://stripe.com/blog/api-versioning">great post</a>.</p><h1 id="breaking_changes">Breaking changes</h1><p>A good way to learn from others’ mistakes is to read <a href="https://stripe.com/docs/upgrades#api-versions">Stripe’s upgrades</a>. Stripe only upgrades the API version when it makes a breaking change somewhere. All backwards-compatible changes are immediately deployed to existing users so they don’t need their own version.</p><p>The rest of the sections have examples of breaking changes that Stripe had to make like this:</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2012-02-23">2011-08-01</a></strong>: Updates the list format. New list objects have a data property that represents an array of objects (by default, 10) and a <code>count</code> property that represents the total count. </p></blockquote><p>From that change, we can learn that list endpoints shouldn’t return a list at the top level. They should be wrapped by a map that can hold other data:</p><pre><code class="javascript">// This shouldn't be the top-level response
[{id: "ex_123"}]

// Do this instead:
{
  data: [{id: "ex_123"}]
  // if you ever need to, you can put data here:
  metadata: "This turned out to be important"
}
</code></pre><h2 id="when_naming,_be_painfully_concrete">When naming, be painfully concrete</h2><p>The first Stripe APIs were all about payments and many of them included <code>balance</code> as a parameter. This was always some <em>payment</em> <code>balance</code>. But over time, as Stripe offered loans, bank accounts, and even cards, <code>balance</code> became a more and more ambiguous word. Are you talking about the loan’s balance or the bank account’s balance?</p><p>Users that come for the newer features like loans will interpret the original <code>balance</code> as loan balances. So, name them <code>payment_balance</code> from the get-go.</p><p>All of this applies to <code>name</code>, <code>account</code>, <code>date</code>, and other similarly vague words.</p><h3 id="beware_of_&lt;code&gt;type&lt;/code&gt;_&lt;strong&gt;and&lt;/strong&gt;_&lt;code&gt;status&lt;/code&gt;">Beware of <code>type</code> <strong>and</strong> <code>status</code></h3><p>What is the <code>type</code> of a payment? While the team is trying to distinguish between subscription payments and one-time payments, they may be tempted to add <code>type: subscriptions | one_time</code>. But years later, a new <code>type</code> might emerge: was this payment made online or in-person?</p><p><code>type</code> implies a form of categorizing, a complete ontology. <code>status</code> does the same but for state machines. But different perspectives require different ontologies and <code>type</code> and <code>status</code> make that first ontology privileged over future ones. What “aspect” of the object are you categorizing?</p><p>Instead of <code>status</code>, can it be <code>fulfillment_status</code>? Instead of <code>type</code>, or can it be <code>timing_type</code>? In my opinion, ugly is better than ambiguous.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2018-08-23">2018-08-23</a>:</strong> The <code>amount</code> field field in the tiers configuration for plans was renamed to <code>unit_amount</code>. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2014-06-13">2014-06-13</a></strong>: Renames the <code>type</code> property on the <code>Card</code> object to <code>brand</code>. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2014-05-19">2014-05-19</a></strong>: Replaces the <code>account</code> property on the <code>Transfer</code> object with <code>bank_account</code>. The <code>bank_account</code> property is only included when the transfer is made to a bank account. </p><p> <strong><a href="https://stripe.com/docs/upgrades#what-changes-does-stripe-consider-to-be-backwards-compatible">2013-12-03</a></strong>: Replaces the <code>user</code> and <code>user_email</code> properties on the Application Fee object with an expandable <code>account</code> property. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2019-03-14">2019-03-04</a></strong>: The <code>date</code> property has been renamed to <code>created</code>. </p></blockquote><h2 id="consider_how_the_api_will_evolve:_hierarchy_and_related_entities">Consider how the API will evolve: hierarchy and related entities</h2><p>Let’s say you are returning a <code>balance</code> that can grow stale. And just in case you add <code>balance_as_of: "2023-01-01T00:00:00"</code>. Over the years, you keep adding <code>balance_xyz</code> fields, one at a time. 5 years later, half of the fields at the top level are <code>balance</code> related and it is hard for developers to find the fields the resource is nominally about. It would’ve been better if <code>balance</code> was a sub-resource, and the fields were <code>balance.as_of</code>, <code>balance.amount</code>, etc.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2015-10-01">2015-10-01</a></strong>: Replaces the <code>bank_accounts</code> property on the Account object with <code>external_accounts</code>. Replaces the <code>bank_account</code> value in the <code>fields_needed</code> property with <code>external_account</code>. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2016-02-19">2016-02-19</a></strong>: Renames the <code>name</code> property on the Bank Account object to <code>account_holder_name</code>. </p></blockquote><h2 id="enums_over_booleans">Enums over booleans</h2><h3 id="input_parameters">Input parameters</h3><p>Even if it feels very black-or-white, use an enum. For example, <code>is_test: false</code> is better as <code>environment: test | live</code>. If later you have <code>staging</code> or even a custom environment, you can still use that enum. Having <code>is_test</code> be a boolean invariable corners you later.</p><p><em>For input parameters,</em> it is backwards compatible to accept a new case in the enum. But it is not backwards compatible to change the field from bool to enum. So get ahead of the problem and use an enum from starters.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2014-09-08">2014-09-08</a></strong>: Replaces the <code>disabled</code>, <code>validated</code>, and <code>verified</code> properties on the Bank Account object with a <code>status</code> enum property. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2017-05-25">2017-05-25</a></strong>: Replaces the <code>managed</code> Boolean property on Account objects with <code>type</code>, whose possible values are: <code>standard</code>, <code>express</code>, and <code>custom</code>. A <code>type</code> value is required when creating accounts. The <code>standard</code> type replaces <code>managed: false</code>, and the <code>custom</code> type replaces <code>managed: true</code>. </p></blockquote><h3 id="return_fields">Return fields</h3><p>Most of the previous section applies to return data as well. It will be easier for you to add an enum case later than to have to reconsider a boolean field. Is that backwards compatible? <em>This depends on the integration pattern</em>.</p><p>Many programming languages check for enum’s exhaustively:</p><pre><code class="typescript">type Data = {
  environment: 'test' | 'live' // Can you add 'staging' here?
}

switch (data.environment) {
  case “test”: {
	...
  }
  case “live”: {
    ...
  }
  // what goes here?
}
</code></pre><p>If the last clause is <code>default</code> and the code does something reasonable for unforeseen cases, then adding cases like <code>staging</code> to an enum is backwards compatible. If not, new enums will break the integration in one of two ways:</p><ol><li>When the new enum is returned to that integration, the code will do something completely unexpected. To make matters worse, JavaScript will throw no exceptions in this case.</li><li>Even if the new enum case was never returned to this particular integration, when the developer updates the SDK bindings with the new types, their compiler will check for exhaustiveness and throw a compile time error. This is vastly better than (1) but still annoying to force the developer to check for something that they don’t care about.</li></ol><p>At Stripe there is a rule that it’s only backwards compatible to return a new enum value if:</p><ul><li>the user opts into it with your integration, like a new payment method type</li><li>the enum fields is clearly not static like a list of banks or currencies</li></ul><p>Keep this in mind when writing documentation and explaining to users how to integrate. If you don’t insist on <code>default</code> clauses, you won’t be able to easily extend enums.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2015-03-24">2014-09-08</a></strong>: Replaces the <code>disabled</code>, <code>validated</code>, and <code>verified</code> properties on the <code>Bank Account</code> object with a <code>status</code> enum property. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2017-05-25">2017-05-25</a></strong>: Replaces the <code>managed</code> Boolean property on <code>Account</code> objects with <code>type</code>, whose possible values are: <code>standard</code>, <code>express</code>, and <code>custom</code>. A <code>type</code> value is required when creating accounts. The <code>standard</code> type replaces <code>managed: false</code>, and the <code>custom</code> type replaces <code>managed: true</code>. </p></blockquote><h2 id="return_as_little_data_as_possible">Return as little data as possible</h2><p>Stripe originally added <code>count</code> on the list endpoint because Mongo returned it from the list queries. It turns out that Mongo struggles to produce that <code>count</code> as collections grow, and it creates all sorts of performance problems. It is not clear that Stripe users need <code>count</code> in the first place. For that and other reasons, list endpoints are some of the worst endpoints to maintain.</p><p>Once <code>count</code> is sent to the user, Stripe doesn’t really know which users depends on it<a href="#fn-3" id="fnref3"><sup>3</sup></a>. It might be the case that very few users depend on <code>count</code> but Stripe has to assume that it is all of them. This is not the case for <em>input parameters</em> where it is easy to track what is being sent to Stripe.</p><p>This example shows one reason you avoid adding data to your responses unless absolutely needed. But when do you add it?</p><ul><li>When important use-cases can’t be completed without it.</li><li>When enough users ask for it, <em>first consider the cost,</em> and then decide it is worth it. This sounds obvious but this whole section is about drilling into you that there are costs of returning data to users.</li></ul><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2014-03-28">2014-03-28</a></strong>: Removes the <code>count</code> property from list responses. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2014-08-04">2014-08-04</a></strong>: Removes the <code>other_transfers</code>, <code>summary</code>, and <code>transactions</code> properties from automatic transfer responses in favor of the balance history endpoint (<code>/v1/balance/history</code>).  These properties were very expensive to calculate on every transfer response, so they were moved to Balance Transactions where the user had to specifically ask for them. </p></blockquote><h2 id="input_data_size_and_length">Input data size and length</h2><p>You will likely want to store many of the strings and arrays that users send you. Make sure to validate those strings and arrays with a max length and to advertise that max length. Otherwise, users will send you really long strings and very long arrays and leave you with a long database bill.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2016-02-22">2016-02-22</a></strong>: Returns an error on attempts to add more than 250 invoice items to an invoice. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2018-10-31">2018-10-31</a></strong>: The <code>description</code> field on customer endpoints has a maximum character length limit of <code>350</code> now. The <code>name</code> field on product endpoints has a maximum character length limit of <code>250</code> now. The <code>description</code> field on invoice line items has a maximum character length limit of <code>500</code> now. </p></blockquote><h2 id="return_data_size">Return data size</h2><p>Developers might store parts of your responses in their databases. For example, they will want to store ids you return (e.g. Stripe uses this format <code>ch_123</code>) alongside their related entities. To do that, they will add columns to tables and in the case of SQL databases, they’ll need to bound the column size with <code>varchar(32)</code> or similar. If you ever make the string longer than 32 chars, they will get an error when storing the id in their database. </p><p>Over the years, Stripe has had to lengthen the size of those ids as it needs that keyspace to be longer or to include more information. To avoid this problem, explain to users that they need 64 characters to store your ids (despite them having 16 right now) or make them sufficiently big from the get-go.</p><h2 id="validations">Validations</h2><p>If you previously accepted untrimmed strings (e.g. <code>“  example “</code>) and you start to reject them, that will break certain integrations. To avoid problems down the line, be very strict and add all the validations that you can think of. You can always drop them later if they prove to a be problem for important use-cases.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2016-02-29">2016-02-29</a></strong>: Adds postal code validation for legal entity addresses when creating and updating accounts </p><p> <strong><a href="https://stripe.com/docs/upgrades#2011-09-15">2011-09-15</a></strong>: Updates the card validation behavior when creating tokens. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2015-09-03">2015-09-03</a></strong>: Returns an error if a request reuses an idempotency token with different parameters than the original request. Previously, errors were only returned for reusing the same idempotency token across different API endpoints. </p></blockquote><h2 id="permissions_and_security">Permissions and security</h2><p>The security model is part of the API. If certain clients are able to access sensitive data now, they should be able to access such data in the future. If your API has different access levels, be especially conservative with the least privileged access levels.</p><p>For example, Stripe has publishable keys for end-user clients like mobile phones and webpages and secret keys for servers. Making a field accessible to publishable keys requires more thinking than making it accessible to secret keys.</p><p>These are particularly serious: you'll need to make a breaking change because you discovered that it is not a good idea to reveal certain data to certain clients, <i>and you'll be in a hurry to make it</i>.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2014-10-07">2014-10-07</a></strong>: Prevents publishable keys from retrieving Token objects. When a card or bank account token is created with a publishable key, the <code>fingerprint</code> property is not included in the response. </p></blockquote><h2 id="loud_errors">Loud errors</h2><p>Imagine if the user send you a bunch of unrelated parameters to your API, what should you do? You might be tempted to simply ignore the parameters. Don’t!</p><p>Consider the parameter <code>send_email: {email_address: "sbensu@gmail.com"}</code>. If they pass that, the developer expects an email to be sent. This is a <em>silent</em> side-effect in that the developer doesn't necessarily learn if the email was sent from the response. What should happen if they typo <code>send_emial</code>? If you ignore bad parameters, <code>send_emial</code> would trigger no errors. The developer would then expect emails to be sent but they wouldn’t. This is bad.</p><p>Extend this thinking to other types of errors or validations beyond misnamed parameters. And do it early, throwing errors for new conditions will be a breaking change.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2012-02-23">2012-02-23</a></strong>: Shows all response fields, even those with null values. Previously, the API hid fields with null values. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2011-06-21">2011-06-21</a></strong>: Raises exceptions on unrecognized parameters passed to the API instead of silently allowing and ignoring them. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2013-02-11">2013-02-11</a></strong>: Updates the pay invoice call to return an error when the charge is not successful. Previously, the API would return a 200 status and set the invoice’s <code>paid</code> property to false. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2013-02-11">2013-02-11</a></strong>: Updates the pay invoice call to return an error when the charge is not successful. Previously, the API would return a 200 status and set the invoice’s <code>paid</code> property to false. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2013-02-11">2015-10-16</a></strong>: Returns an error if a <code>tax_percent</code> is provided without a plan during a customer update or creation. </p></blockquote><h2 id="behavior_changes">Behavior changes</h2><p>As <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a> suggests, if your API has enough integrations, some of them will depend on the behavior that you want to change, <em>even bugs</em>. Consider this change from Stripe’s Upgrades:</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2015-03-24">2015-03-24</a></strong>: Updates coupons so they no longer apply to negative invoice items by default. Previously, coupons applied to all non-proration invoice items. To allow a coupon to apply to a negative invoice item, pass <code>discountable=true</code> when creating or updating the invoice item. </p></blockquote><p>There was a clear in bug in how coupons were applied to certain invoices. But fixing it would break people who relied on this math and had created coupons with a reversed-engineer amount to work around the bug. To avoid breaking those integrations, Stripe created a new version.</p><p>This doesn’t mean that you should never fix bugs. Use your common sense to try to bound how many integrations could’ve plausibly depended on the bug's behavior and if the number is low enough, fix it without a new version. Otherwise, you’ll have to broadcast the change and cut a new version.</p><p>A similar example is smallest currency unit. Dollars have cents and the Stripe API denominates all USD amounts in cents, <code>{currency: "usd", amount: 100}</code> is $1. Integrations need to divide by 100 to render it to their users. But other currencies like the Japanese Yen don’t have cents, only Yens. <code>{currency: "jpy", amount: 100}</code> is ¥100, no division required.</p><p>Over time currencies evolve, some lose their cents<a href="#fn-4" id="fnref4"><sup>4</sup></a> (i.e. inflation). Stripe can’t just stop passing the cents since everyone has their own math for it<a href="#fn-5" id="fnref5"><sup>5</sup></a>. So, currencies updates are considered breaking changes. </p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2013-12-03">2013-12-03</a></strong>: Updates the refunding of application fees to be proportional to the amount of the charge refunded (when setting <code>refund_application_fee=true</code>). Previously, the entire application fee was refunded even when only part of the charge was. </p></blockquote><p>And if the new behavior is not a bug but rather a change in the APIs side-effects, you almost surely want to cut a new version.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2013-10-29">2013-10-29</a></strong>: Changes coupon behavior so that applying an amount-off coupon to an invoice does not increase the Customer account balance if the discount is greater than the invoice amount. Coupons are ignored—and not counted as redeemed—when applied to zero-cost invoices. This change does not apply to coupons created on earlier API version. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2014-01-31">2014-01-31</a></strong>: Ignores trial dates on canceled subscriptions when automatically computing trial end dates for new subscriptions. </p></blockquote><h2 id="implicit_semantics:_fingerprints_and_ids">Implicit semantics: fingerprints and ids</h2><p>Certain identifiers or keys sometimes have implicit meanings:</p><ul><li>Is this id unique across different accounts? Or only within an account?</li><li>Are the ids sequential? Can you compare ids with <code>&lt;</code> to see which one was generated first? If the user reads <code>123</code> and <code>124</code>, they might conclude your ids are sequential.</li><li>Are the ids hierarchical? <code>"invoice_123_line_item_345"</code> leads the user to think that they can extract the <code>invoice_id</code> from that id.</li></ul><p>When creating such ids or tokens, be careful about their implied semantics and compared those to <i>how they look</i>. You might be generating the ids sequentially, but that might not be a promise you want to make. If so, either change how the identifiers look or be very explicit about how the identifiers can be used.</p><blockquote><p> <strong><a href="https://stripe.com/docs/upgrades#2018-01-23">2018-01-23</a></strong>: When being viewed by a platform, cards and bank accounts created on behalf of connected accounts will have a fingerprint that is universal across all connected accounts. For accounts that are not connect platforms, there will be no change. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2018-05-21">2018-05-21</a></strong>: The <code>id</code> field of invoice line items of <code>type: subscription</code> no longer can be interpreted as a subscription ID, but instead is a unique invoice line item ID. It can be used for pagination. </p><p> <strong><a href="https://stripe.com/docs/upgrades#2019-12-03">2019-12-03</a></strong>: You can no longer use the prefix of the <code>id</code> to determine the source of the line item. Instead use the <code>type</code> field for this purpose. </p></blockquote><h2 id="default_values">Default values</h2><p>The PaymentIntent API doesn’t require the developer to pass <code>payment_method_types</code>. The API interprets no value as default value:</p><pre><code class="javascript">POST /v1/payment_intents
{
  amount: 1000,
  currency: "usd"
}
</code></pre><p>is automatically interpreted as:</p><pre><code class="javascript">POST /v1/payment_intents
{
  amount: 1000,
  currency: "usd",
  payment_method_types: ["card"] // &lt;-- default value
}
</code></pre><p>If you change the default values to be something else (e.g. <code>payment_method_types: ["card", "link"]</code>), you are changing what the API does without an integration change.</p><p>In most cases, changing default values is not backwards compatible. So, unless you are sure that a default is the best idea, don’t offer default values and ask the developer to pass the exact value that they need.</p><h2></h2><p><em>Thanks to Michelle Bu for reading drafts and providing valuable feedback and Adam D’Angelo for prompting the essay. Special thanks to Remi Jannel, Stripe API custodian, for providing feedback, commentary, and many of the examples included.</em></p><h2></h2><h1 id="footnotes">Footnotes</h1><ol class="footnotes"><li id="fn-1">Some of it also applies to gRPC Protos and GraphQL but not to the same extent.<a href="#fnref1">↩</a></li><li id="fn-2"><a href="https://www.youtube.com/watch?v=YR5WdGrpoug">This talk</a> by Rich Hickey expands on this problem.<a href="#fnref2">↩</a></li><li id="fn-3">This is one of the advantages of GraphQL for API maintainers: the API users have to ask for the specific properties that they need in their return values. This makes it possible to determine which properties are popular and which ones are unused.<a href="#fnref3">↩</a></li><li id="fn-4">The Icelandic króna is dropping their cents (aurar) as I write this essay. See <a href="https://www.cb.is/publications/news/news/2003/08/15/Withdrawal-of-coin-denominated-in-aurar/">Withdrawal of coin denominated in aurar</a>.<a href="#fnref4">↩</a></li><li id="fn-5">To make problems worse for users, different payment processors treat these currencies differently.<a href="#fnref5">↩</a></li></ol>
</div>
<!-- 
<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags/Software/">Software</a>
    
</div>

 -->

    <div id="prev-next">
        
        <a href="/posts/team-oriented-vs-outcome-oriented/">&laquo; Team-oriented, outcome-oriented</a>
        
        
        <a class="right" href="/posts/api-avoid-breaking-changes/">How to avoid breaking APIs &raquo;</a>
        
    </div>
</div>

            </div>
        </div>
    </div>
</div>

<footer></footer>

<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
<script src="/js/highlight.pack.js" type="application/javascript"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
 
ga('create', 'UA-66101645-1', 'auto');
ga('send', 'pageview');
</script>
</body>
</html>
