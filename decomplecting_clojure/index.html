<!DOCTYPE html>

<html></html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" /><title>A blog</title><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}})</script><link type="text/css" rel="stylesheet" media="screen,projection" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/css/materialize.css" /><link type="text/css" rel="stylesheet" media="screen,projection" href="/css/style.css" /><link type="text/css" rel="stylesheet" href="/css/solarized-light.css" /><script type="text/javascript" src="//www.google-analytics.com/analytics.js"></script><script type="text/javascript" src="/js/analytics.js"></script></head><body><nav role="navigation" class="blue-grey  darken-1"><div class="nav-wrapper container"><ul class="right hide-on-med-and-down"><li><a href="/">Home</a></li><li><a href="/archive">Archive</a></li><li><a target="_blank" href="https://github.com/bensu">Github</a></li></ul><ul id="nav-mobile" class="side-nav"><li><a href="/">Home</a></li><li><a href="/archive">Archive</a></li><li><a target="_blank" href="https://github.com/bensu">Github</a></li></ul><a href="#" data-activates="nav-mobile" class="button-collapse"><i class="mdi-navigation-menu"></i></a></div></nav><div class="post-body"><header><div id="index-banner" class="section no-pad-bot"><div class="container"><h4 class="header center">Decomplecting Clojure</h4></div></div></header><main><div class="container light"><div class="blue-grey-text text-darken-4 row block"><p>Clojure is a programming language that combines several concepts in a unique way. From the outside it is hard to understand the value or importance of these concepts, and to make matters worse, they are often blurred together. As Rich Hickey, the creator of the language, suggests, taking a system apart is difficult but worth it. After "decomplecting" you end up with smaller pieces which are easier to reason about and even build newer things.</p><p>Though targeted to beginners, this is not an introduction to the language, but an attempt to explain it. In the process I steal from many sources and leave out technologies like <code>core.async</code> and <code>core.match</code><sup>1</sup> that, though powerful and important, don't characterize Clojure.</p><p>Let's break Clojure apart and see what does each piece bring to the table.</p><h5>The JVM</h5><p>Clojure's Runtime is implemented in Java. Code can be dynamically loaded into a running JVM or compiled into Java Byte Code for later use. Some of the benefits of using the JVM are: </p>
<ul>
  <li>Clojure can leverage Java libraries. Through Java interop, Clojure had an  <a href="http://eclipse.org/jetty/">HTTP server</a>,  a <a href="https://www.bouncycastle.org/java.html">crypto library</a>, and a  <a href="http://search.maven.org/">package repository</a> from day  one<sup>2</sup>. This is specially useful for huge projects (i.e.  Apache family) that target the JVM. Not all Java projects are easy to use  from Clojure:  <a href="http://docs.oracle.com/javase/7/docs/api/java/io/File.html">some</a>  APIs can be comfortably used through Java interop,  <a href="https://github.com/clj-time/clj-time">others</a>  can be wrapped with Clojure to provide a more familiar  interface, and a few are so far away from Clojure's semantics that  no amount of wrapping can make them palatable.</li>
  <li>Clojure can be deployed wherever Java can and every infrastructure  supplier supports Java.</li>
  <li>Clojure implements many abstractions on top of Java and they are not  without cost. The upside is that whenever extra performance is  needed, you can go one level down and use Java.</li>
  <li>The JVM ecosystem has armies working on optimization,  profiling, monitoring, and debugging. According to Colin Fleming,  the man behind <a href="https://cursiveclojure.com/">Cursive</a>, it is great to  work with such mature tooling. He also mentioned that the  implementation details of Clojure are unavoidable when dealing with  Byte Code, but luckily for us <em>he</em> has chosen to do it.</li>
</ul><p>The JVM makes Clojure <strong>practical</strong>.</p><p>Every decision comes with trade-offs. Firstly, the JVM doesn't know about Clojure which leads to:</p>
<ul>
  <li>Slow start times: when the JVM is started, it must first load Clojure  itself and then proceed to run your code. This makes the current  implementation of Clojure unsuitable for  <a href="http://blog.ndk.io/2015/04/23/state-of-coa.html">Android development</a>  and command line tools where an extra second of loading time is  unacceptable. That being said, the community is working to improve  <a href="https://github.com/mfikes/cljs-cl">on</a>  <a href="http://clojure-android.info/skummet/">all</a> <a href="http://dev.clojure.org/display/design/'Lean'+Runtime">fronts</a>.</li>
  <li>Poor stack traces: stack traces contain all the underlying Java  classes and methods involved. Even if there is a clear mapping  between Clojure code and Java classes, they are noisy  and hard to decipher. Experience and tools help but Clojure stack  traces are very daunting for beginners.</li>
</ul><p>Secondly, you inherit all the JVM's limitations:</p>
<ul>
  <li>No tail call optimization. Clojure works around it by  introducing <a href="https://clojuredocs.org/clojure.core/loop"><code>loop</code></a> and  <a href="https://clojuredocs.org/clojure.core/recur"><code>recur</code></a> which make  tail calls explicit.</li>
  <li>Code Reloading is hard. The JVM is not designed with code reloading in  mind which makes an interactive workflow harder. The  community has overcome this limitation with amazing  <a href="https://github.com/clojure/tools.namespace">tools</a> and  <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">discipline</a>  but if you are heavily redefining functions you'll sometimes need to  restart the JVM.</li>
</ul><h5>Functional Style</h5><p>The Clojure standard library draws a lot of inspiration from the ML family of languages and heavily features lazy collections. There are plenty of blog posts describing how Functional Programming will solve all your problems and even help you <em>lose weight with this weird trick</em> but let's limit the hype.</p><p>I find the "collection + lambdas" approach more powerful than "loops + iterators". Higher-order functions and currying describe your intent more succinctly and allow for more reuse. It is the difference between seeing the forest and only seeing trees:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="p">(</span><span class="nb">map inc </span><span class="nv">some-array</span><span class="p">))</span>
</code></pre>
<pre class="highlight"><code class="java"><span class="n">B</span> <span class="o">=</span> <span class="o">[];</span>
<span class="n">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">someArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">someArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEven</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">B</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><p>With that said, I object to statements like this made-up quote:</p>
<blockquote><p>Functional programming is declarative: you tell the computer <em>what</em> you want and not <em>how</em> to get it.</p>
</blockquote><p>Whenever you specify the steps of a computation you are telling the computer how to get something (i.e., increment all elements by one, and then give me only the even ones). You might be describing less and doing more, but it is far from declarative as such statements imply. This is different from logic programming where you state truths about your domain and then query it. </p><p>A functional style makes Clojure <strong>elegant</strong>.</p><h5>Lisp</h5><p>Lisp is many things to many people, a religion to some and an antique to others. To me it represents two distinct things: a syntax and an approach to designing and developing code.</p><p>Lisp programs are defined in terms of s-expressions which have consistent syntax. An s-expression is list of symbols where the first symbol is the operator, the rest are its arguments, and when evaluated it returns a value:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nf">op</span> <span class="nv">arg1</span> <span class="nv">arg2</span> <span class="nv">...</span> <span class="nv">arg-n</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; =&gt; 2</span>
</code></pre><p>Since the expression is a list (not a string!), it can easily be manipulated by other programs. For example, if you wanted to find the operator of any s-expression:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nb">first </span><span class="o">'</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; =&gt; + </span>
</code></pre><p>A consistent syntax is crucial when writing macros, programs that write/modify other programs. Macros are <a href="http://www.paulgraham.com/avg.html">powerful</a> because they allow you to write language extensions. If your Lisp is missing feature X, you could probably write a set of macros to implement it. A good example is <code>core.async</code>: the team behind Clojure added Go's concurrency model to the language with a library using macros and without modifying the language itself.</p><p>s-expressions come with some trade-offs:</p>
<ul>
  <li><p>Parenthesis whining: beginners and non lispers dislike them and  complain loudly. It took me a couple of weeks to naturally read  s-expressions but it was definitely worth it. Also, some operators like  <code>&lt;</code> are always hard to read at the beginning of the expression.</p></li>
  <li><p>Macro abuse: some hackers like to experiment with macro DSLs making  their code harder to read and use consistently. It is less  of a problem when using popular Clojure libraries since it is  regarded as good practice to write macros only when you have to<sup>3</sup>.</p></li>
</ul><p>s-expressions can be written and tested individually which leads to an interactive development style. You type expressions in a REPL (most modern languages come with REPLs, shells, or consoles) and modify them until they return the desired value. Any tool that <a href="https://www.youtube.com/watch?v=KZjFVdU8VLI">makes</a> <a href="https://www.youtube.com/watch?v=mKsL9ZRfXWw">development</a> <a href="https://www.youtube.com/watch?v=H58-n7uldoU">interactive</a> is valuable to the Clojure community.</p><p>Building s-expressions from the ground up is not only fun, it also leads you to compose small abstractions into larger ones. The strategy is called <a href="http://www.paulgraham.com/progbot.html">bottom-up</a> programming and allows for tremendous reuse. If your abstractions have well-defined interfaces it can also be called <em>layered</em> programming, as presented in Chapter 2 of <a href="https://www.youtube.com/watch?v=ymsbTVLbyN4&amp;list=PL8FE88AA54363BC46&amp;index=4">SICP</a>. SICP and Clojure go one step further by guiding you into giving those components and abstractions the Closure property. An operation has the Closure property if it takes and returns elements of the same type X, allowing you to combine them in some fashion:</p>
<pre class="highlight"><code class="clj"><span class="c1">;; integers are closed under +</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">40</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; 42 - an integer</span>

<span class="c1">;; sets can be merged into a bigger set</span>
<span class="p">(</span><span class="nf">set/union</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">3</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">;; =&gt; #{1 2 3}</span>

<span class="c1">;; functions can be *comp*osed into other functions</span>
<span class="p">(</span><span class="nb">comp zero? </span><span class="nv">mod</span><span class="p">)</span> <span class="c1">;; =&gt; divisible-by? - a function</span>
</code></pre><p>True to its name, Clojure data has <em>closure</em> under most of the core library. This is such a big thing that it deserves an entire section.</p><p>Lisp makes Clojure <strong>powerful</strong>.</p><h5>Data as Data</h5><p>Clojure comes with four main data structures and nudges you into modeling your domain with them. In most cases you don't need to create your own types. Instead, you use the available data structures and use all of the core library.</p><p>The opposite approach is to define your own types and classes, and then add methods to them. It is hard to explain how much simpler the end result is when using Clojure's data structures. To make my point, I will steal <a href="http://programming-puzzler.blogspot.se/2013/12/clojure-vs-scala.html">this example</a> since it perfectly captures what I mean. Let's say you need to model a deck of cards. Choose your favorite language and picture what you would do. Would you write something like this?</p>
<pre class="highlight"><code class="java"><span class="kd">class</span> <span class="nc">Card</span> <span class="o">{</span>
  <span class="nl">rank:</span> <span class="n">Int</span>
  <span class="nl">suit:</span> <span class="n">Enum</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Deck</span> <span class="o">{</span>
  <span class="nl">deck:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span>
<span class="o">}</span>
</code></pre><p>In Clojure you would just use a vector for the Card, <code>[3 :spades]</code>, and a vector of cards for the deck, <code>[[3 :spades] [1 :hearts]]</code>. Now you can leverage all of Clojure's functions. For example, "get me a poker hand out of a deck of cards":</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">mapcat </span><span class="o">#</span><span class="p">(</span><span class="nb">map vector </span><span class="p">(</span><span class="nb">range </span><span class="mi">13</span><span class="p">)</span> <span class="p">(</span><span class="nb">repeat </span><span class="nv">%</span><span class="p">))</span>
              <span class="p">[</span><span class="ss">:spades</span> <span class="ss">:hearts</span> <span class="ss">:diamonds</span> <span class="ss">:clubs</span><span class="p">])</span>
      <span class="nv">shuffle</span>
      <span class="p">(</span><span class="nb">take </span><span class="mi">2</span><span class="p">))</span> <span class="c1">;; We are playing Hold'em</span>
</code></pre><p>I don't expect you to read that but to understand that we are only using data structures and functions provided by Clojure. We are not adding any abstractions to model and manipulate our domain and the resulting code is simple and straightforward.</p><p>Now think about adding the <code>shuffle</code> and <code>sort</code> methods to the <code>Deck</code> class (without forgetting <code>compare</code> for <code>Card</code>!). Since you've wrapped your data, you now have to dispatch each function you need from your class to the underlying implementation, e.g., <code>deck.shuffle()</code> to <code>innerList.shuffle()</code>. All that extra work is needed to reduce the distance between the custom types and the language. Is it necessary? Type safety and speed can justify it, that is not for me to decide. The point is that when you treat Data as Data, code flows from you hands because you have the full power of the language at your disposal. </p><p>Data as Data makes Clojure <strong>simple</strong>.</p><h5>Immutability</h5><p>Clojure data structures are immutable: once defined they can't be changed. If there is something that changes as time moves forward (state), you need to explicitly define it as mutable and change it through a well defined interface. Immutability helps you write concurrent code. To understand how, let's analyze the opposite: how does mutability make concurrency hard. </p><p>For example, your server needs to know many clients are connected at any time. In most OO languages you would define some object to hold the <code>count</code>:</p>
<pre class="highlight"><code class="java"><span class="c1">// On each connection</span>
<span class="k">if</span> <span class="n">client</span><span class="o">.</span><span class="na">isNew</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">clientCount</span> <span class="o">=</span> <span class="n">clientCounter</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
    <span class="c1">// What if somebody connects right *now*?</span>
    <span class="n">clientCounter</span><span class="o">.</span><span class="na">setCount</span><span class="o">(</span><span class="n">clientCount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><p>You are first retrieving the value, then adding one to it, and then setting it. There is a window of time in which you are holding a version of <code>clientCount</code> that might not represent the real count. What if a new client connects in between those statements? Concurrency is hard, and Clojure offers <a href="https://www.youtube.com/watch?v=dGVqrGmwOAw">many</a> tools to deal with it. I'll present one of them.</p><p>In Clojure, you would define one mutable reference <code>client-count</code> and then mutate it through a transaction:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="k">def </span><span class="nv">client-count</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">new-client?</span> <span class="nv">client-id</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">swap!</span> <span class="nv">client-count</span> <span class="nv">inc</span><span class="p">))</span>
</code></pre><p><code>swap!</code> means: apply the function <code>inc</code> to the value in <code>client-count</code> and then swap the old value and the new result. There are no unsafe variables involved.</p><p>State management improves something that I consider more important than concurrency: design. Having to define your state forces you to examine the system and model it clearly. You don't have objects that have important state and objects that are just stateful. You minimize the moving parts and just like in mechanical engineering, your design improves.</p><p>Immutability makes Clojure programs <strong>easy to reason about</strong>.</p><h5>Principles &amp; Community</h5><p>You may have noticed that I've used words like "simple" and "design" more than usual. They hint at the language's underlying philosophy. Talks by Rich Hickey and members of the community (notably Zach Tellman and David Nolen) show <em>good taste</em> <sup>4</sup>. The presented ideas come from thought and analysis, not improvisation or convenience.</p><p>Clojure starts by carefully stating problems and recognizing that good solutions come after discarding bad ones, which explains why "Not everything is awesome" is a mantra in the community. The community is reluctant to adopt libraries/frameworks that are not the <em>right solution to the right problem</em>.</p><p>In its quest for the perfect design, Clojure acknowledges that there is no such thing. Every decision involves trade-offs, even those you make by default. For example, big web frameworks are not popular since most users would rather weigh their options for their particular problem instead of scaffold a template with the "standard settings".</p><p>What's the problem with standard settings? It depends. In many cases, there is no problem. The standard settings apply to your system and are easy to setup since they come with modules that fit together. What happens after a while, when your business evolves and requirements change? If said modules assume one another, it will be hard to replace any of them. The system was easy to build but it is not simple to modify, and <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple is better than Easy</a> Clojure takes the Single Responsibility Principle to a new level. When choosing a module you ask the following questions:</p>
<ul>
  <li>Does it do one thing very well?</li>
  <li>Does it have many dependencies?</li>
  <li>Can I replace it with a similar module in the future?</li>
</ul><p>If the answer to any of those is "No", you discard it. Clojure modules should do one thing well and swap dependencies easily. A great example is Datomic: a database that can use several <a href="http://docs.datomic.com/storage.html">storage services</a>. </p><p>Clojure's unifying objective is to help you manage the complexity of your software by reducing the incidental complexity created by your tools and allow you to focus on the essential complexity of your domain.</p><p>In my eyes, these principles make Clojure, well, <strong>Clojure</strong>.</p>
<hr /><p><sup>1</sup><code>core.match</code> is a library that provides pattern matching to the language and <code>core.async</code> provides utilities to write async code following the <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP model</a>, like Go. Since they could only be written as a library with macros, they are testament to the power of macros.</p><p><sup>2</sup>From a historical perspective, targeting the JVM helped Clojure overcome the chicken-and-egg problem all new languages face: nobody wants to program in a language with no libraries, and no one wants to develop libraries for a language with no users.</p><p><sup>3</sup>Zach Tellman has a great <a href="https://www.youtube.com/watch?v=o69H0MXCNxw">talk</a> on how/when to use macros.</p><p><sup>4</sup>As in Kant's Aesthetics.</p></div></div></main></div><footer class="blue-grey  page-footer darken-1"><div class="blue-grey-text text-lighten-3 container"><div class="row"></div></div></footer><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/js/materialize.js"></script><script src="/js/init.js"></script></body></html>
