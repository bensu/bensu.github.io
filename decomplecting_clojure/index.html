<!DOCTYPE html>

<html></html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" /><title>A blog</title><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}})</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66101645-1', 'auto');
  ga('send', 'pageview');
</script><link type="text/css" rel="stylesheet" media="screen,projection" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/css/materialize.css" /><link type="text/css" rel="stylesheet" media="screen,projection" href="/css/style.css" /></head></html><link type="text/css" rel="stylesheet" href="/css/solarized-light.css" /><body><nav role="navigation" class="blue-grey  darken-1"><div class="nav-wrapper container"><ul class="right hide-on-med-and-down"><li><a href="/">Home</a></li><li><a href="/archive">Archive</a></li><li><a target="_blank" href="https://github.com/bensu">Github</a></li></ul><ul id="nav-mobile" class="side-nav"><li><a href="/">Home</a></li><li><a href="/archive">Archive</a></li><li><a target="_blank" href="https://github.com/bensu">Github</a></li></ul><a href="#" data-activates="nav-mobile" class="button-collapse"><i class="mdi-navigation-menu"></i></a></div></nav><div class="post-body"><header><div id="index-banner" class="section no-pad-bot"><div class="container"><h4 class="header center">Decomplecting Clojure</h4></div></div></header><main><div class="container light"><div class="blue-grey-text text-darken-4 row block"><p>Clojure's core philosophy is that systems should be composed out of small and simple pieces. We can trace the concept to its Lisp inheritance but also to its functional/ML side, or are they the same? As Rich Hickey suggests, taking a part a system or an idea is difficult but worth it. After "decomplecting" the system, you end up with smaller pieces which are easier to reason about and even build newer things.</p><p>Though targeted to beginners, this is not a syntactical overview nor an introduction, but an attempt to understand what Clojure is about. In the process I steal from many sources and leave out things like <code>core.async</code> and <code>core.match</code> that, though powerful and important, don't characterize Clojure.</p><p>Let's decomplect Clojure and see what value does each part provide.</p><h5>The JVM</h5><p>Clojure's Runtime is implemented in Java. Code can be dynamically loaded into a running JVM or compiled into Java Byte Code for later use (ahead of time compilation, AOT). Some of the benefits of using the JVM are: </p>
<ul>
  <li>Clojure can leverage Java libraries. Through Java interop, Clojure had an  <a href="http://eclipse.org/jetty/">HTTP server</a>,  a <a href="https://www.bouncycastle.org/java.html">crypto library</a>, and a  <a href="http://search.maven.org/">package repository</a> from day  one<sup>1</sup>. This is specially useful for huge projects (i.e.  Apache family) that target the JVM. Not all Java projects are easy to use  from Clojure:  <a href="http://docs.oracle.com/javase/7/docs/api/java/io/File.html">some</a>  APIs can be comfortably used through Java interop,  <a href="https://github.com/clj-time/clj-time">others</a>  can be wrapped with Clojure to provide a more familiar  interface, and a few are so far away from Clojure's semantics that  no amount of wrapping can make them palatable.</li>
  <li>Clojure can be deployed wherever Java can, which is a  big win since every infrastructure supplier supports Java.</li>
  <li>Whenever extra performance is needed, you can go one level down  and replace the inner-inner loop with Java.</li>
  <li>The JVM ecosystem already has armies working on optimization,  profiling, monitoring, and debugging. According to Colin Fleming,  the man behind <a href="https://cursiveclojure.com/">Cursive</a>, it is great to  work with such mature tooling. He also mentioned that the  implementation details of Clojure are unavoidable when dealing with  Byte Code, but luckily for us <em>he</em> has chosen to do it :)</li>
</ul><p>The JVM makes Clojure <strong>practical</strong>.</p><p>With every decision there are some trade-offs. Firstly, the JVM doesn't know about Clojure which leads to:</p>
<ul>
  <li>Slow start times: when the JVM is started, it must first load Clojure  itself and then proceed to run your code. This makes the current  implementation of Clojure unsuitable for  <a href="http://blog.ndk.io/2015/04/23/state-of-coa.html">Android development</a>  and command line tools where an extra second of loading time is  unacceptable. That being said, the Clojure  community is working to improve <a href="https://github.com/mfikes/cljs-cl">on</a>  <a href="http://clojure-android.info/skummet/">all</a> <a href="http://dev.clojure.org/display/design/'Lean'+Runtime">fronts</a>.</li>
  <li>Poor stack traces: when a Clojure program fails the JVM throws a  stack trace with all the underlying Java classes and methods  involved. Even if there is a clear mapping  between Clojure code and Java classes, the stack traces are noisy  and hard to decipher. Experience and tools help but Clojure stack  traces are very daunting for beginners.</li>
</ul><p>Secondly, you inherit all the of the JVM's limitations:</p>
<ul>
  <li>No tail call optimization. This is not a big issue in Java where  iteration is preferred over recursion but it might become one after  the introduction of lambdas. Clojure works around by  introducing <a href="https://clojuredocs.org/clojure.core/loop"><code>loop</code></a> and  <a href="https://clojuredocs.org/clojure.core/recur"><code>recur</code></a> which makes  your tail calls explicit.</li>
  <li>Code Reloading is hard. The JVM is not design with code reloading in  mind which makes a REPL workflow a little harder. The Clojure  community has patched this limitation with amazing  <a href="https://github.com/clojure/tools.namespace">tools</a> and  <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">discipline</a>  but if you are heavily redefining functions and you doubt your  REPL's state you'll need to restart the JVM.</li>
</ul><h5>ML Inheritance</h5><p>The Clojure standard library draws a lot of inspiration from the ML family of languages and heavily features lazy collections. There are plenty blog posts describing how Functional Programming will solve all your problems and even help you <em>loose weight with this weird trick</em>.</p><p>I find the "collection + lambdas" approach more powerful than "loops + iterators". Higher order functions and currying describe your intent more succinctly and allow for more reuse. It is the difference between seeing the forest and only seeing trees:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="p">(</span><span class="nb">map inc </span><span class="nv">some-array</span><span class="p">))</span>
</code></pre>
<pre class="highlight"><code class="java"><span class="n">B</span> <span class="o">=</span> <span class="o">[];</span>
<span class="n">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">someArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">someArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEven</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">B</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><p>With that said, I object to statements like this made-up-quote:</p>
<blockquote><p>Functional programming is declarative: you tell the computer <em>what</em> you want and not <em>how</em> to get it.</p>
</blockquote><p>Whenever you specify the steps of a computation you are telling the computer how to get something (i.e. increment all elements by one, and then give me only the even ones). You might be describing less and doing more, but it is far from declarative as such quotes imply. This is different from logic programming where you state truths about your domain and then query it. </p><p>A functional style makes Clojure <strong>elegant</strong>.</p><h5>Lisp</h5><p>Lisp is many things to many people, a religion to some and an antique to others. To me it represents two distinct things: a syntax and an approach to designing and developing code.</p><p>Lisp programs are defined in term of s-expressions which have consistent syntax:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nf">operation</span> <span class="nv">arg-one</span> <span class="nv">arg-two</span> <span class="nv">...</span> <span class="nv">arg-n</span><span class="p">)</span>
</code></pre><p>The basic expression represents a list where the first token is the operator to be applied to the arguments. Since the expression is a list (not a string!), it can easily be manipulated by other programs. For example, if you wanted to find the operator of any lisp expression (s-expression), you would just need to find the first element of the list:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nb">first </span><span class="o">'</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">;; =&gt; + </span>
</code></pre><p>A consistent syntax is crucial when writing macros, which are programs that write/modify other programs. I'm not going to go into why macros are powerful but it boils down to this: you can add language extensions. If your Lisp is missing feature X, you could probably write a macro or a set of macros that implement it. <a href="http://www.paulgraham.com/onlisp.html">OnLisp</a> puts great focus on macros and even builds an Object system with methods and properties (remember feature X?) in a language that lacks them.</p><p>I don't have much experience writing macros but they have saved me a few times. Zach Tellman gave a <a href="https://www.youtube.com/watch?v=o69H0MXCNxw">great talk</a> on how and when we should be using macros in Clojure.</p><p>Besides plain syntax, Lisp comes with a philosophy about how software should be designed and developed. Lispers develop their systems by designing lower level abstractions and components that can be used to build higher levels. This strategy is called <em>bottom-up</em> programming and if your abstractions have well-defined interfaces it can also be called <em>layered</em> programming.</p><p>Clojure also guides you into giving those components and abstractions the Closure property. An operation has the Closure property if it takes and returns elements of the same type X, allowing you to combine them in some fashion.</p>
<pre class="highlight"><code class="clj"><span class="c1">;; integers are closed under +</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">40</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; =&gt; 42 - an integer</span>

<span class="c1">;; sets can be merged into a bigger set</span>
<span class="p">(</span><span class="nf">set/union</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">3</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">;; =&gt; #{1 2 3}</span>

<span class="c1">;; and intersected into a smaller set</span>
<span class="p">(</span><span class="nf">set/intersection</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">3</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">;; =&gt; #{1}</span>

<span class="c1">;; functions can be *comp*osed into other functions</span>
<span class="p">(</span><span class="nb">comp zero? </span><span class="nv">mod</span><span class="p">)</span> <span class="c1">;; =&gt; divisible-by? - a function</span>
</code></pre><p>The Closure property makes building higher levels increasingly easier because you can combine a few lower level components into new ones and get tremendous reuse. None of these ideas are exclusive to Lisp but they play an important part in its development style.</p><p>Most of these are ideas are explained in the great SICP, based on another Lisp dialect, Scheme. The Closure property and Compound Data are discussed in <a href="https://www.youtube.com/watch?v=ymsbTVLbyN4&amp;list=PL8FE88AA54363BC46&amp;index=4">lesson 2B</a> of the video lectures and Chapter 2 of the book.</p><p>Finally, Lisp encourages interactive development with a REPL. Most programmers are now familiar with REPLs and every browser comes with a JavaScript console. Any tool that <a href="https://www.youtube.com/watch?v=KZjFVdU8VLI">makes</a> <a href="https://www.youtube.com/watch?v=mKsL9ZRfXWw">development</a> <a href="https://www.youtube.com/watch?v=H58-n7uldoU">interactive</a> is valuable to the Clojure community.</p><p>Lisp makes Clojure <strong>powerful</strong>.</p><p>s-expressions come with some trade-offs:</p>
<ul>
  <li><p>Parenthesis whining: beginners and non lispers are put off by them and  complain loudly. It took me a couple of weeks to naturally read  s-expressions but it was definitely worth it. <a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Editing  tools</a>  that understand the structure of your code are a one way road.</p></li>
  <li><p>Macro abuse: some hackers like to experiment with macro DSLs making  their code harder to read and use consistently. It is less  of a problem when using popular Clojure libraries since it is  regarded as good practice to write macros only when you have to.</p></li>
</ul><h5>Data as Data</h5><p>Tautologies and quotes are not only great conversation starters, they also remind you of things you knew but forgot about. For example: "keep it simple, stupid", "things should be made as simple as possible but not simpler". In Clojure you take this approach by modeling your domain using plain data. To make my point, I will steal <a href="http://programming-puzzler.blogspot.se/2013/12/clojure-vs-scala.html">this example</a> since it perfectly captures what I mean. Let's say you need to model a deck of cards. Choose your favorite language and picture what you would do. Would you write something like this?</p>
<pre class="highlight"><code class="java"><span class="kd">class</span> <span class="nc">Card</span> <span class="o">{</span>
  <span class="nl">rank:</span> <span class="n">Int</span>
  <span class="nl">suit:</span> <span class="n">Enum</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Deck</span> <span class="o">{</span>
  <span class="nl">deck:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span>
<span class="o">}</span>
</code></pre><p>In Clojure you would just use a vector, <code>[3 :spades]</code>. That's it. The great upside is that since your card is just Clojure data, you can leverage all of Clojure's functions. For example, "get me a poker hand out of a deck of cards":</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">mapcat </span><span class="o">#</span><span class="p">(</span><span class="nb">map vector </span><span class="p">(</span><span class="nb">range </span><span class="mi">13</span><span class="p">)</span> <span class="p">(</span><span class="nb">repeat </span><span class="nv">%</span><span class="p">))</span>
              <span class="p">[</span><span class="ss">:spades</span> <span class="ss">:hearts</span> <span class="ss">:diamonds</span> <span class="ss">:clubs</span><span class="p">])</span>
      <span class="nv">shuffle</span>
      <span class="p">(</span><span class="nb">take </span><span class="mi">2</span><span class="p">))</span> <span class="c1">;; We are playing Hold'em</span>
</code></pre><p>Having that code, can you write a program that takes 5 cards, sorts them by rank, and then serializes them? Hint, the standard library has all you need, including <code>sort-by</code> and <code>pr-str</code>.</p><p>Now think about adding the <code>shuffle</code> and <code>sort</code> methods to the <code>Deck</code> class (without forgetting <code>compare</code> for <code>Card</code>). All that extra work is needed to reduce the distance between the custom types and the language. Is it necessary? Type safety and speed can justify it, that is not for me to decide. The point is that when you treat Data as Data, code flows from you hands because you have the full power of the language at your disposal. The author responsible for the cards example encourages us to use the term <em>lightweight data modeling</em> which captures how Clojure feels like.</p><p>Data as Data makes Clojure a <strong>joy</strong> to work with.</p><h5>Immutability &amp; Software Transactional Memory (STM)</h5><p>Clojure data structures are immutable: once you define them you are not allowed to change them. If there is something you want to change as time moves forward, you need to explicitly define it as mutable and change it through a well defined interface, Software Transactional Memory. STM only allows for transactions (as in database transactions) and not direct mutation (setters and getters).</p><p>Let's say your server needs to know how many clients are connected at any time. In most OO languages you would define some object to hold the <code>count</code>:</p>
<pre class="highlight"><code class="java"><span class="c1">// On each connection</span>
<span class="k">if</span> <span class="n">client</span><span class="o">.</span><span class="na">isNew</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">clientCount</span> <span class="o">=</span> <span class="n">clientCounter</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
    <span class="c1">// What if somebody connects right *now*?</span>
    <span class="n">clientCounter</span><span class="o">.</span><span class="na">setCount</span><span class="o">(</span><span class="n">clientCount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><p>You can name these instructions however you like but the point is that you will first retrieve the value, then add one to it, and then set it. There is a window of time in which you are holding a version of <code>clientCount</code> that might not represent the real count. What if in between those statements a new client connects? Clojure approach to concurrency is explained by Rich Hickey <a href="https://www.youtube.com/watch?v=dGVqrGmwOAw">here</a>.</p><p>In Clojure, we would define one mutable reference <code>client-count</code> and then mutate it through a transaction:</p>
<pre class="highlight"><code class="clj"><span class="p">(</span><span class="k">def </span><span class="nv">client-count</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">new-client?</span> <span class="nv">client-id</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">swap!</span> <span class="nv">client-count</span> <span class="nv">inc</span><span class="p">))</span>
</code></pre><p><code>swap!</code> means: apply the function <code>inc</code> to the value in <code>client-count</code> and then swap the old value and the new result. At no point in time we had an unsafe variable.</p><p>STM is Clojure's approach to concurrency but it brings to your programs something I consider more important: better design.</p><p>Having to specify what can mutate forces you to examine the system and model it clearly. You don't add flags here and there to signal things. You don't have objects that have important state and objects that are just stateful. You are forced to minimize the moving parts, and just like in mechanical engineering, your design improves.</p><p>Immutability makes Clojure programs <strong>concurrent by default</strong> and <strong>easy to reason about it</strong>.</p><h5>Principles &amp; Community</h5><p>This is what got me interested in Clojure. Most talks by Rich Hickey and other members of the community (notably Zach Tellman, David Nolen, and Stuart Halloway) show <em>good taste</em>. The ideas and design principles come from thought and analysis, not improvisation and necessity. This might only mean that I like those ideas and principles but there is some objective beauty to sound solutions and the Clojure community has plenty of those.</p><p>The community starts by recognizing that to get good solutions you must discard bad ones. Enter "Not everything is awesome". The community is reluctant to adopt ideas/libraries/frameworks if they are not the <em>right solution to the right problem</em>. To contribute to the language you must follow strict guidelines and be willing to argue why your way is the best way<sup>2</sup>. Quality and good design are valued above all else. </p><p>On the way to finding that perfect design, Clojure starts by acknowledging that there is no such thing. Every decision you make involves trade-offs, even those you make by default. Though true everywhere, Clojure strongly emphasizes it. For example, big web frameworks are not popular since most users would rather weigh their options for their particular problem instead of scaffold a template with the "standard settings".</p><p>What's the problem with standard settings and big frameworks? It depends. In many cases, there is no problem. The standard settings apply to your system and are easy to setup since they come with a bunch of modules that fit together. What happens after a while, when your business evolves, requirements change? If said modules assume one another, it will be very hard to replace any of them. All the pieces are tangled. The system was easy to build but it is not simple, and Simple is better than Easy. If you haven't seen <a href="https://www.youtube.com/watch?v=rI8tNMsozo0">Rich Hickey's</a> talks, the one liner is: Clojure takes the single responsibility principle to a new level. When you choose/design a module you ask the following questions:</p>
<ul>
  <li>Does it do one thing very well?</li>
  <li>Does it have many dependencies?</li>
  <li>Can I replace it with a similar module in the future?</li>
</ul><p>If the answer to any of those is "No", then you don't choose it. In Clojure you are encouraged to write modules that do one thing well and can swap dependencies easily. A great example is Datomic: a database that can use several <a href="http://docs.datomic.com/storage.html">storage services</a>. </p><p>There is an underlying objective that drives these principles and leads to the design choices and solutions outlined above. Clojure is designed to help you manage the complexity of your software. The main strategy is to remove incidental complexity from your tools and let you focus on the essential complexity of your domain.</p><p>In my eyes, these principles are what make Clojure a <strong>game changer</strong>.</p>
<hr /><p><sup>1</sup>From a historical perspective, targeting the JVM helped Clojure overcome the chicken and egg problem all new languages face. Nobody wants to program in a language with no libraries, and no one wants to develop libraries for a language with no users.</p><p><sup>2</sup>I have not contributed to Clojure but to ClojureScript.</p></div></div></main></div><footer class="blue-grey  page-footer darken-1"><div class="blue-grey-text text-lighten-3 container"><div class="row"></div></div></footer><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.96.1/js/materialize.js"></script><script src="/js/init.js"></script></body>