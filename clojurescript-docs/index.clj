{:namespaces
 ({:doc nil,
   :name "cljs.analyzer",
   :wiki-url "cljs.analyzer-api.html",
   :source-url nil}
  {:doc
   "This is intended to be a stable api for those who need programmatic access\nto ClojureScript's project building facilities.\n\nFor example: a build script may need to how to invalidate compiled\nfiles so that they will be recompiled.",
   :name "cljs.build.api",
   :wiki-url "cljs.build.api-api.html",
   :source-url nil}
  {:doc
   "Compile ClojureScript to JavaScript with optimizations from Google\n Closure Compiler producing runnable JavaScript.\n\n The Closure Compiler (compiler.jar) must be on the classpath.\n\n Use the 'build' function for end-to-end compilation.\n\n build = find-sources -> add-dependencies -> compile -> optimize -> output\n\n Two protocols are defined: IJavaScript and Compilable. The\n Compilable protocol is satisfied by something which can return one\n or more IJavaScripts.\n\n With IJavaScript objects in hand, calling add-dependencies will\n produce a sequence of IJavaScript objects which includes all\n required dependencies from the Closure library and ClojureScript,\n in dependency order. This function replaces the closurebuilder\n tool.\n\n The optimize function converts one or more IJavaScripts into a\n single string of JavaScript source code using the Closure Compiler\n API.\n\n The produced output is either a single string of optimized\n JavaScript or a deps file for use during development.\n",
   :name "cljs.closure",
   :wiki-url "cljs.closure-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.compiler",
   :wiki-url "cljs.compiler-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.core",
   :wiki-url "cljs.core-api.html",
   :source-url nil}
  {:doc
   "A namespace that exists solely to provide a place for \"compiler\"\nstate that is accessed/maintained by many different components.",
   :name "cljs.env",
   :wiki-url "cljs.env-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.js",
   :wiki-url "cljs.js-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.js-deps",
   :wiki-url "cljs.js-deps-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.pprint",
   :wiki-url "cljs.pprint-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.repl",
   :wiki-url "cljs.repl-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.source-map",
   :wiki-url "cljs.source-map-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.spec",
   :wiki-url "cljs.spec-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.stacktrace",
   :wiki-url "cljs.stacktrace-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.support",
   :wiki-url "cljs.support-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.tagged-literals",
   :wiki-url "cljs.tagged-literals-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.test",
   :wiki-url "cljs.test-api.html",
   :source-url nil}
  {:doc nil,
   :name "cljs.util",
   :wiki-url "cljs.util-api.html",
   :source-url nil}
  {:doc
   "This is intended to be a stable api for those who need programmatic access\nto the analyzer.",
   :name "cljs.analyzer.api",
   :wiki-url "cljs.analyzer-api.html#cljs.analyzer.api",
   :source-url nil}
  {:doc
   "This is intended to be a stable api for those who need programmatic access\nto the compiler.",
   :name "cljs.compiler.api",
   :wiki-url "cljs.compiler-api.html#cljs.compiler.api",
   :source-url nil}
  {:doc nil,
   :name "cljs.env.macros",
   :wiki-url "cljs.env-api.html#cljs.env.macros",
   :source-url nil}
  {:doc nil,
   :name "cljs.repl.browser",
   :wiki-url "cljs.repl-api.html#cljs.repl.browser",
   :source-url nil}
  {:doc nil,
   :name "cljs.repl.nashorn",
   :wiki-url "cljs.repl-api.html#cljs.repl.nashorn",
   :source-url nil}
  {:doc nil,
   :name "cljs.repl.node",
   :wiki-url "cljs.repl-api.html#cljs.repl.node",
   :source-url nil}
  {:doc nil,
   :name "cljs.repl.reflect",
   :wiki-url "cljs.repl-api.html#cljs.repl.reflect",
   :source-url nil}
  {:doc nil,
   :name "cljs.repl.rhino",
   :wiki-url "cljs.repl-api.html#cljs.repl.rhino",
   :source-url nil}
  {:doc nil,
   :name "cljs.repl.server",
   :wiki-url "cljs.repl-api.html#cljs.repl.server",
   :source-url nil}
  {:doc nil,
   :name "cljs.spec.impl.gen",
   :wiki-url "cljs.spec-api.html#cljs.spec.impl.gen",
   :source-url nil}
  {:doc nil,
   :name "cljs.spec.test",
   :wiki-url "cljs.spec-api.html#cljs.spec.test",
   :source-url nil}),
 :vars
 ({:raw-source-url nil,
   :name "aliasable-clj-ns?",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 1899,
   :var-type "function",
   :arglists ([sym]),
   :doc
   "Predicate for testing with a symbol represents an aliasable clojure namespace.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/aliasable-clj-ns?"}
  {:raw-source-url nil,
   :name "analyze",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2727,
   :var-type "function",
   :arglists ([env form] [env form name] [env form name opts]),
   :doc
   "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n(one of :statement, :expr, :return), :ns (a symbol naming the\ncompilation ns)}, and form, returns an expression object (a map\ncontaining at least :form, :op and :env keys). If expr has any (immediately)\nnested exprs, must have :children [exprs...] entry. This will\nfacilitate code walking without knowing the details of the op set.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/analyze"}
  {:raw-source-url nil,
   :name "analyze-deps",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 1687,
   :var-type "function",
   :arglists ([lib deps env] [lib deps env opts]),
   :doc
   "Given a lib, a namespace, deps, its dependencies, env, an analysis environment\nand opts, compiler options - analyze all of the dependencies. Required to\ncorrectly analyze usage of other namespaces.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/analyze-deps"}
  {:raw-source-url nil,
   :name "analyze-file",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2960,
   :var-type "function",
   :arglists ([f] [f opts] [f skip-cache opts]),
   :doc
   "Given a java.io.File, java.net.URL or a string identifying a resource on the\nclasspath attempt to analyze it.\n\nThis function side-effects the ambient compilation environment\n`cljs.env/*compiler*` to aggregate analysis information. opts argument is\ncompiler options, if :cache-analysis true will cache analysis to\n\":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\nmeaningful value.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/analyze-file"}
  {:raw-source-url nil,
   :name "analyze-symbol",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2386,
   :var-type "function",
   :arglists ([env sym]),
   :doc "Finds the var associated with sym",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/analyze-symbol"}
  {:raw-source-url nil,
   :name "cache-file",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2890,
   :var-type "function",
   :arglists
   ([src]
    [src output-dir]
    [src ns-info output-dir]
    [src ns-info output-dir mode]),
   :doc
   "Given a ClojureScript source file returns the read/write path to the analysis\ncache file. Defaults to the read path which is usually also the write path.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/cache-file"}
  {:raw-source-url nil,
   :name "clj-ns->cljs-ns",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 1889,
   :var-type "function",
   :arglists ([sym]),
   :doc
   "Given a symbol that starts with clojure as the first segment return the\nsame symbol with the first segment replaced with cljs",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/clj-ns->cljs-ns"}
  {:raw-source-url nil,
   :name "confirm-bindings",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 797,
   :var-type "function",
   :arglists ([env names]),
   :doc
   "Given env, an analysis environment env, and names, a list of symbols, confirm\nthat all correspond to declared dynamic vars.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/confirm-bindings"}
  {:raw-source-url nil,
   :name "confirm-ns",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 691,
   :var-type "function",
   :arglists ([env ns-sym]),
   :doc
   "Given env, an analysis environment, and ns-sym, a symbol identifying a\nnamespace, confirm that the namespace exists. Warn if not found.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/confirm-ns"}
  {:raw-source-url nil,
   :name "core-name?",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 705,
   :var-type "function",
   :arglists ([env sym]),
   :doc
   "Is sym visible from core in the current compilation namespace?",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/core-name?"}
  {:raw-source-url nil,
   :name "desugar-ns-specs",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 1928,
   :var-type "function",
   :arglists ([args]),
   :doc
   "Given an original set of ns specs desugar :include-macros and :refer-macros\nusage into only primitive spec forms - :use, :require, :use-macros,\n:require-macros. If a library includes a macro file of with the same name\nas the namespace will also be desugared.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/desugar-ns-specs"}
  {:raw-source-url nil,
   :name "empty-env",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 568,
   :var-type "function",
   :arglists ([]),
   :doc
   "Construct an empty analysis environment. Required to analyze forms.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/empty-env"}
  {:raw-source-url nil,
   :name "forms-seq",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2785,
   :var-type "function",
   :arglists ([f] [f filename] [f filename return-reader?]),
   :doc
   "DEPRECATED: Seq of Clojure/ClojureScript forms from [f], which can be anything\nfor which `clojure.java.io/reader` can produce a `java.io.Reader`. Optionally\naccepts a [filename] argument, which the reader will use in any emitted errors.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/forms-seq"}
  {:raw-source-url nil,
   :name "forms-seq*",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2754,
   :var-type "function",
   :arglists ([rdr] [rdr filename]),
   :doc
   "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\naccepts a filename argument which will be used in any emitted errors.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/forms-seq*"}
  {:raw-source-url nil,
   :name "get-expander",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2457,
   :var-type "function",
   :arglists ([sym env]),
   :doc
   "Given a sym, a symbol identifying a macro, and env, an analysis environment\nreturn the corresponding Clojure macroexpander.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/get-expander"}
  {:raw-source-url nil,
   :name "infer-tag",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 940,
   :var-type "function",
   :arglists ([env e]),
   :doc
   "Given env, an analysis environment, and e, an AST node, return the inferred\ntype of the node",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/infer-tag"}
  {:raw-source-url nil,
   :name "intern-macros",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 517,
   :var-type "function",
   :arglists ([ns] [ns reload]),
   :doc
   "Given a Clojure namespace intern all macros into the ambient ClojureScript\nanalysis environment.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/intern-macros"}
  {:raw-source-url nil,
   :name "loaded-js-ns?",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 645,
   :var-type "function",
   :arglists ([env prefix]),
   :doc
   "Check if a JavaScript namespace has been loaded. JavaScript vars are\nnot currently checked.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/loaded-js-ns?"}
  {:raw-source-url nil,
   :name "locate-src",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 1658,
   :var-type "function",
   :arglists ([ns]),
   :doc
   "Given a namespace return the corresponding ClojureScript (.cljs or .cljc)\nresource on the classpath or file from the root of the build.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/locate-src"}
  {:raw-source-url nil,
   :name "macro-autoload-ns?",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 1874,
   :var-type "function",
   :arglists ([form]),
   :doc
   "Given a spec form check whether the spec namespace requires a macro file\nof the same name. If so return true.",
   :namespace "cljs.analyzer",
   :wiki-url
   "/cljs.analyzer-api.html#cljs.analyzer/macro-autoload-ns?"}
  {:raw-source-url nil,
   :name "macroexpand-1",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2526,
   :var-type "function",
   :arglists ([env form]),
   :doc
   "Given a env, an analysis environment, and form, a ClojureScript form,\nmacroexpand the form once.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/macroexpand-1"}
  {:raw-source-url nil,
   :name "parse-ns",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2815,
   :var-type "function",
   :arglists ([src] [src opts] [src dest opts]),
   :doc
   "Helper for parsing only the essential namespace information from a\nClojureScript source file and returning a cljs.closure/IJavaScript compatible\nmap _not_ a namespace AST node.\n\nBy default does not load macros or perform any analysis of dependencies. If\nopts parameter provided :analyze-deps and :load-macros keys their values will\nbe used for *analyze-deps* and *load-macros* bindings respectively. This\nfunction does _not_ side-effect the ambient compilation environment unless\nrequested via opts where :restore is false.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/parse-ns"}
  {:raw-source-url nil,
   :name "requires-analysis?",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 2911,
   :var-type "function",
   :arglists ([src] [src output-dir] [src cache output-dir]),
   :doc
   "Given a src, a resource, and output-dir, a compilation output directory\nreturn true or false depending on whether src needs to be (re-)analyzed.\nCan optionally pass cache, the analysis cache file.",
   :namespace "cljs.analyzer",
   :wiki-url
   "/cljs.analyzer-api.html#cljs.analyzer/requires-analysis?"}
  {:raw-source-url nil,
   :name "resolve-existing-var",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 789,
   :var-type "function",
   :arglists ([env sym]),
   :doc
   "Given env, an analysis environment, and sym, a symbol, resolve an existing var.\nEmits a warning if no such var exists.",
   :namespace "cljs.analyzer",
   :wiki-url
   "/cljs.analyzer-api.html#cljs.analyzer/resolve-existing-var"}
  {:raw-source-url nil,
   :name "resolve-macro-var",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 807,
   :var-type "function",
   :arglists ([env sym]),
   :doc
   "Given env, an analysis environment, and sym, a symbol, resolve a macro.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/resolve-macro-var"}
  {:raw-source-url nil,
   :name "resolve-var",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 715,
   :var-type "function",
   :arglists ([env sym] [env sym confirm]),
   :doc
   "Resolve a var. Accepts a side-effecting confirm fn for producing\nwarnings about unresolved vars.",
   :namespace "cljs.analyzer",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer/resolve-var"}
  {:raw-source-url nil,
   :name "rewrite-cljs-aliases",
   :file "src/main/clojure/cljs/analyzer.cljc",
   :source-url nil,
   :line 1909,
   :var-type "function",
   :arglists ([args]),
   :doc
   "Alias non-existing clojure.* namespaces to existing cljs.* namespaces if\npossible.",
   :namespace "cljs.analyzer",
   :wiki-url
   "/cljs.analyzer-api.html#cljs.analyzer/rewrite-cljs-aliases"}
  {:raw-source-url nil,
   :name "add-dependencies",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 143,
   :var-type "function",
   :arglists ([opts & ijss]),
   :doc
   "Given one or more IJavaScript objects in dependency order, produce\na new sequence of IJavaScript objects which includes the input list\nplus all dependencies in dependency order.",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/add-dependencies"}
  {:raw-source-url nil,
   :name "add-implicit-options",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 150,
   :var-type "function",
   :arglists ([opts]),
   :doc
   "Given a valid map of build options add any standard implicit options. For\nexample :optimizations :none implies :cache-analysis true and :source-map\ntrue.",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/add-implicit-options"}
  {:raw-source-url nil,
   :name "build",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 198,
   :var-type "function",
   :arglists ([source opts] [source opts compiler-env]),
   :doc
   "Given a source which can be compiled, produce runnable JavaScript.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/build"}
  {:raw-source-url nil,
   :name "cljs-dependents-for-macro-namespaces",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 49,
   :var-type "function",
   :arglists ([namespaces] [state namespaces]),
   :doc
   "Takes a list of Clojure (.clj) namespaces that define macros and\nreturns a list ClojureScript (.cljs) namespaces that depend on those macro\nnamespaces.\n\nFor example where example.macros is defined in the clojure file\n\"example/macros.clj\" and both 'example.core and 'example.util are\nClojureScript namespaces that require and use the macros from\n'example.macros :\n(cljs-dependents-for-macro-namespaces 'example.macros) ->\n('example.core 'example.util)",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/cljs-dependents-for-macro-namespaces"}
  {:raw-source-url nil,
   :name "compile",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 176,
   :var-type "function",
   :arglists ([opts compilable] [state opts compilable]),
   :doc "Given a Compilable, compile it and return an IJavaScript.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/compile"}
  {:raw-source-url nil,
   :name "goog-dep-string",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 113,
   :var-type "function",
   :arglists ([opts ijs]),
   :doc
   "Given compiler options and a IJavaScript instance return the corresponding\ngoog.addDependency string",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/goog-dep-string"}
  {:raw-source-url nil,
   :name "inputs",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 157,
   :var-type "function",
   :arglists ([& xs]),
   :doc
   "Given a list of directories and files, return a compilable object that may\nbe passed to build or watch.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/inputs"}
  {:raw-source-url nil,
   :name "mark-cljs-ns-for-recompile!",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 41,
   :var-type "function",
   :arglists ([ns-sym] [ns-sym output-dir]),
   :doc
   "Backdates a cljs target file so that it the cljs compiler will recompile it.",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/mark-cljs-ns-for-recompile!"}
  {:raw-source-url nil,
   :name "ns->location",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 130,
   :var-type "function",
   :arglists ([ns] [ns compiler-env]),
   :doc
   "Given a namespace and compilation environment return the relative path and\nuri of the corresponding source regardless of the source language extension:\n.cljs, .cljc, .js. Returns a map containing :relative-path a string, and\n:uri a URL.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/ns->location"}
  {:raw-source-url nil,
   :name "ns->source",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 125,
   :var-type "function",
   :arglists ([ns]),
   :doc
   "Given a namespace as a symbol return the corresponding resource if it exists.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/ns->source"}
  {:raw-source-url nil,
   :name "output-unoptimized",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 188,
   :var-type "function",
   :arglists ([opts & sources]),
   :doc
   "Ensure that all JavaScript source files are on disk (not in jars),\nwrite the goog deps file including only the libraries that are being\nused and write the deps file for the current project.\n\nThe deps file for the current project will include third-party\nlibraries.",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/output-unoptimized"}
  {:raw-source-url nil,
   :name "parse-js-ns",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 73,
   :var-type "function",
   :arglists ([f]),
   :doc
   "Given a Google Closure style JavaScript file or resource return the namespace\ninformation for the given file. Only returns the value extracted from the\nfirst provide statement.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/parse-js-ns"}
  {:raw-source-url nil,
   :name "source-on-disk",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 119,
   :var-type "function",
   :arglists ([opts ijs]),
   :doc
   "Ensure that the given IJavaScript exists on disk in the output directory.\nReturn updated IJavaScript with the new location if necessary.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/source-on-disk"}
  {:raw-source-url nil,
   :name "src-file->goog-require",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 95,
   :var-type "function",
   :arglists ([src] [src options] [state src options]),
   :doc
   "Given a ClojureScript or Google Closure style JavaScript source file return\nthe goog.require statement for it.",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/src-file->goog-require"}
  {:raw-source-url nil,
   :name "src-file->target-file",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 80,
   :var-type "function",
   :arglists ([src] [src opts] [state src opts]),
   :doc
   "Given a ClojureScript source file return the target file. May optionally\nprovide build options with :output-dir specified.",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/src-file->target-file"}
  {:raw-source-url nil,
   :name "target-file-for-cljs-ns",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 28,
   :var-type "function",
   :arglists ([ns-sym] [ns-sym output-dir]),
   :doc
   "Given an output directory and a clojurescript namespace return the\ncompilation target file for that namespace.\n\nFor example:\n(target-file-from-cljs-ns \"resources/out\" 'example.core) ->\n<File: \"resources/out/example/core.js\">",
   :namespace "cljs.build.api",
   :wiki-url
   "/cljs.build.api-api.html#cljs.build.api/target-file-for-cljs-ns"}
  {:raw-source-url nil,
   :name "watch",
   :file "src/main/clojure/cljs/build/api.clj",
   :source-url nil,
   :line 212,
   :var-type "function",
   :arglists
   ([source opts]
    [source opts compiler-env]
    [source opts compiler-env stop]),
   :doc
   "Given a source which can be compiled, watch it for changes to produce.",
   :namespace "cljs.build.api",
   :wiki-url "/cljs.build.api-api.html#cljs.build.api/watch"}
  {:raw-source-url nil,
   :name "->JavaScriptFile",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 372,
   :var-type "function",
   :arglists
   ([foreign url source-url provides requires lines source-map]),
   :doc
   "Positional factory function for class cljs.closure.JavaScriptFile.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/->JavaScriptFile"}
  {:raw-source-url nil,
   :name "add-dep-string",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1367,
   :var-type "function",
   :arglists ([opts input]),
   :doc "Return a goog.addDependency string for an input.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/add-dep-string"}
  {:raw-source-url nil,
   :name "add-dependencies",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 741,
   :var-type "function",
   :arglists ([opts & inputs]),
   :doc
   "Given one or more IJavaScript objects in dependency order, produce\na new sequence of IJavaScript objects which includes the input list\nplus all dependencies in dependency order.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/add-dependencies"}
  {:raw-source-url nil,
   :name "add-dependency-sources",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 791,
   :var-type "function",
   :arglists ([inputs] [inputs compile-opts]),
   :doc
   "Given list of IJavaScript objects, produce a new sequence of IJavaScript objects\nof all dependencies of inputs.",
   :namespace "cljs.closure",
   :wiki-url
   "/cljs.closure-api.html#cljs.closure/add-dependency-sources"}
  {:raw-source-url nil,
   :name "add-js-sources",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 880,
   :var-type "function",
   :arglists ([inputs opts]),
   :doc
   "Given list of IJavaScript objects, add foreign-deps, constants-table\nIJavaScript objects to the list.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/add-js-sources"}
  {:raw-source-url nil,
   :name "add-preloads",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 912,
   :var-type "function",
   :arglists ([inputs opts]),
   :doc
   "Add :preloads to a given set of inputs (IJavaScript). Returns a new\nlist of inputs where the preloaded namespaces and their deps come immediately after\ncljs.core or the constants table depending on the optimization setting. Any\nfiles needing copying or compilation will be compiled and/or copied to the\nappropiate location.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/add-preloads"}
  {:raw-source-url nil,
   :name "build",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1937,
   :var-type "function",
   :arglists ([source opts] [source opts compiler-env]),
   :doc
   "Given a source which can be compiled, produce runnable JavaScript.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/build"}
  {:raw-source-url nil,
   :name "build-modules",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1057,
   :var-type "function",
   :arglists ([sources opts]),
   :doc
   "Given a list of IJavaScript sources in dependency order and compiler options\nreturn a dependency sorted list of module name / description tuples. The\nmodule descriptions will be augmented with a :closure-module entry holding\nthe Closure JSModule. Each module description will also be augmented with\na :foreign-deps vector containing foreign IJavaScript sources in dependency\norder.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/build-modules"}
  {:raw-source-url nil,
   :name "build-provides",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 994,
   :var-type "function",
   :arglists ([provides]),
   :doc
   "Given a vector of provides, builds required goog.provide statements",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/build-provides"}
  {:raw-source-url nil,
   :name "cljs-dependencies",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 683,
   :var-type "function",
   :arglists ([opts requires]),
   :doc
   "Given a list of all required namespaces, return a list of\nIJavaScripts which are the cljs dependencies. The returned list will\nnot only include the explicitly required files but any transitive\ndependencies as well. JavaScript files will be compiled to the\nworking directory if they do not already exist.\n\nOnly load dependencies from the classpath.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/cljs-dependencies"}
  {:raw-source-url nil,
   :name "cljs-source-for-namespace",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 639,
   :var-type "function",
   :arglists ([ns]),
   :doc
   "Given a namespace return the corresponding source with either a .cljs or\n.cljc extension.",
   :namespace "cljs.closure",
   :wiki-url
   "/cljs.closure-api.html#cljs.closure/cljs-source-for-namespace"}
  {:raw-source-url nil,
   :name "compile",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 459,
   :var-type "function",
   :arglists ([compilable opts]),
   :doc "Given a Compilable, compile it and return an IJavaScript.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/compile"}
  {:raw-source-url nil,
   :name "compile-dir",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 479,
   :var-type "function",
   :arglists ([src-dir opts]),
   :doc
   "Recursively compile all cljs files under the given source\ndirectory. Return a list of JavaScriptFiles.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/compile-dir"}
  {:raw-source-url nil,
   :name "compile-file",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 464,
   :var-type "function",
   :arglists ([file {:keys [output-file], :as opts}]),
   :doc
   "Compile a single cljs file. If no output-file is specified, returns\na string of compiled JavaScript. With an output-file option, the\ncompiled JavaScript will written to this location and the function\nreturns a JavaScriptFile. In either case the return value satisfies\nIJavaScript.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/compile-file"}
  {:raw-source-url nil,
   :name "compile-form-seq",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 434,
   :var-type "function",
   :arglists ([forms]),
   :doc "Compile a sequence of forms to a JavaScript source string.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/compile-form-seq"}
  {:raw-source-url nil,
   :name "compile-from-jar",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 510,
   :var-type "function",
   :arglists ([jar-file {:keys [output-file], :as opts}]),
   :doc "Compile a file from a jar if necessary. Returns IJavaScript.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/compile-from-jar"}
  {:raw-source-url nil,
   :name "compile-sources",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 855,
   :var-type "function",
   :arglists ([inputs opts] [inputs compiler-stats opts]),
   :doc
   "Takes dependency ordered list of IJavaScript compatible maps from parse-ns\nand compiles them.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/compile-sources"}
  {:raw-source-url nil,
   :name "compiled-file",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 444,
   :var-type "function",
   :arglists ([m]),
   :doc
   "Given a map with at least a :file key, return a map with\n{:file .. :provides .. :requires ..}.\n\nCompiled files are cached so they will only be read once.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/compiled-file"}
  {:raw-source-url nil,
   :name "convert-js-module",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1563,
   :var-type "multimethod",
   :arglists nil,
   :doc
   "Takes a JavaScript module as an IJavaScript and rewrites it into a Google\nClosure-compatible form. Returns an IJavaScript with the converted module\ncode set as source.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/convert-js-module"}
  {:raw-source-url nil,
   :name "deps-file",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1380,
   :var-type "function",
   :arglists ([opts sources]),
   :doc "Return a deps file string for a sequence of inputs.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/deps-file"}
  {:raw-source-url nil,
   :name "emit-optimized-source-map",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1166,
   :var-type "function",
   :arglists ([sm-json sources name opts]),
   :doc
   "Given a JSON parsed Google Closure JavaScript to JavaScript source map,\nthe entire list of original IJavaScript sources output a merged JavaScript\nto ClojureScript source map file with the given file name. opts should\nsupply :preamble-line-count and :foreign-deps-line-count if they are\nrelevant.",
   :namespace "cljs.closure",
   :wiki-url
   "/cljs.closure-api.html#cljs.closure/emit-optimized-source-map"}
  {:raw-source-url nil,
   :name "find-cljs-dependencies",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 719,
   :var-type "function",
   :arglists ([requires]),
   :doc
   "Given set of cljs namespace symbols, find IJavaScript objects for the namespaces.",
   :namespace "cljs.closure",
   :wiki-url
   "/cljs.closure-api.html#cljs.closure/find-cljs-dependencies"}
  {:raw-source-url nil,
   :name "get-compiled-cljs",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 631,
   :var-type "function",
   :arglists ([opts {:keys [relative-path uri]}]),
   :doc
   "Return an IJavaScript for this file. Compiled output will be\nwritten to the working directory.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/get-compiled-cljs"}
  {:raw-source-url nil,
   :name "get-upstream-deps*",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1751,
   :var-type "function",
   :arglists ([] [classloader]),
   :doc
   "returns a merged map containing all upstream dependencies defined\nby libraries on the classpath.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/get-upstream-deps*"}
  {:raw-source-url nil,
   :name "jar-file-to-disk",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 493,
   :var-type "function",
   :arglists ([url out-dir] [url out-dir opts]),
   :doc
   "Copy a file contained within a jar to disk. Return the created file.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/jar-file-to-disk"}
  {:raw-source-url nil,
   :name "js-dependencies",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 593,
   :var-type "function",
   :arglists ([opts requires]),
   :doc
   "Given a sequence of Closure namespace strings, return the list of\nall dependencies. The returned list includes all Google and\nthird-party library dependencies.\n\nThird-party libraries are configured using the :libs option where\nthe value is a list of directories containing third-party\nlibraries.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/js-dependencies"}
  {:raw-source-url nil,
   :name "js-transforms",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1623,
   :var-type "multimethod",
   :arglists nil,
   :doc
   "Takes an IJavaScript with the source code set as source, transforms the\nsource code and returns an IJavascript with the new code set as source.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/js-transforms"}
  {:raw-source-url nil,
   :name "known-opts",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 164,
   :var-type "var",
   :arglists nil,
   :doc "Set of all known compiler options.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/known-opts"}
  {:raw-source-url nil,
   :name "load-externs",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 291,
   :var-type "function",
   :arglists
   ([{:keys [externs use-only-custom-externs target ups-externs]}]),
   :doc
   "Externs are JavaScript files which contain empty definitions of\nfunctions which will be provided by the environment. Any function in\nan extern file will not be renamed during optimization.\n\nOptions may contain an :externs key with a list of file paths to\nload. The :use-only-custom-externs flag may be used to indicate that\nthe default externs should be excluded.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/load-externs"}
  {:raw-source-url nil,
   :name "make-options",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 252,
   :var-type "function",
   :arglists ([opts]),
   :doc
   "Create a CompilerOptions object and set options from opts map.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/make-options"}
  {:raw-source-url nil,
   :name "map->JavaScriptFile",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 372,
   :var-type "function",
   :arglists ([m#]),
   :doc
   "Factory function for class cljs.closure.JavaScriptFile, taking a map of keywords to field values.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/map->JavaScriptFile"}
  {:raw-source-url nil,
   :name "optimize",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1271,
   :var-type "function",
   :arglists ([opts & sources]),
   :doc
   "Use the Closure Compiler to optimize one or more JavaScript files.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/optimize"}
  {:raw-source-url nil,
   :name "optimize-modules",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1224,
   :var-type "function",
   :arglists ([opts & sources]),
   :doc
   "Use the Closure Compiler to optimize one or more Closure JSModules. Returns\na dependency sorted list of module name and description tuples.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/optimize-modules"}
  {:raw-source-url nil,
   :name "output-modules",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1444,
   :var-type "function",
   :arglists ([opts js-sources modules]),
   :doc
   "Given compiler options, original IJavaScript sources and a sequence of\nmodule name and module description tuples output module sources to disk.\nModules description must define :output-to and supply :source entry with\nthe JavaScript source to write to disk.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/output-modules"}
  {:raw-source-url nil,
   :name "output-unoptimized",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1708,
   :var-type "function",
   :arglists ([opts & sources]),
   :doc
   "Ensure that all JavaScript source files are on disk (not in jars),\nwrite the goog deps file including only the libraries that are being\nused and write the deps file for the current project.\n\nThe deps file for the current project will include third-party\nlibraries.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/output-unoptimized"}
  {:raw-source-url nil,
   :name "path-from-jarfile",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 487,
   :var-type "function",
   :arglists ([url]),
   :doc
   "Given the URL of a file within a jar, return the path of the file\nfrom the root of the jar.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/path-from-jarfile"}
  {:raw-source-url nil,
   :name "path-relative-to",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1354,
   :var-type "function",
   :arglists ([base input]),
   :doc
   "Generate a string which is the path to the input IJavaScript relative\nto the specified base file.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/path-relative-to"}
  {:raw-source-url nil,
   :name "process-js-modules",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1914,
   :var-type "function",
   :arglists ([opts]),
   :doc
   "Given the current compiler options, converts JavaScript modules to Google\nClosure modules and writes them to disk. Adds mapping from original module\nnamespace to new module namespace to compiler env. Returns modified compiler\noptions where new modules are passed with :libs option.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/process-js-modules"}
  {:raw-source-url nil,
   :name "read-js",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 410,
   :var-type "function",
   :arglists ([f]),
   :doc "Read a JavaScript file returning a map of file information.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/read-js"}
  {:raw-source-url nil,
   :name "rel-output-path",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1505,
   :var-type "function",
   :arglists ([js] [js opts]),
   :doc
   "Given an IJavaScript which is either in memory, in a jar file,\nor is a foreign lib, return the path relative to the output\ndirectory.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/rel-output-path"}
  {:raw-source-url nil,
   :name "set-options",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 195,
   :var-type "function",
   :arglists ([opts compiler-options]),
   :doc "TODO: Add any other options that we would like to support.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/set-options"}
  {:raw-source-url nil,
   :name "source-for-namespace",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 654,
   :var-type "function",
   :arglists ([ns compiler-env]),
   :doc
   "Given a namespace and compilation environment return the relative path and\nuri of the corresponding source regardless of the source language extension:\n.cljs, .cljc, .js",
   :namespace "cljs.closure",
   :wiki-url
   "/cljs.closure-api.html#cljs.closure/source-for-namespace"}
  {:raw-source-url nil,
   :name "source-on-disk",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1674,
   :var-type "function",
   :arglists ([opts js]),
   :doc
   "Ensure that the given IJavaScript exists on disk in the output directory.\nReturn updated IJavaScript with the new location if necessary.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/source-on-disk"}
  {:raw-source-url nil,
   :name "watch",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 2059,
   :var-type "function",
   :arglists
   ([source opts]
    [source opts compiler-env]
    [source opts compiler-env quit]),
   :doc
   "Given a source directory, produce runnable JavaScript. Watch the source\ndirectory for changes rebuliding when necessary. Takes the same arguments as\ncljs.closure/build in addition to :watch-fn, a function of no arguments to\nrun after a successful build.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/watch"}
  {:raw-source-url nil,
   :name "write-javascript",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1633,
   :var-type "function",
   :arglists ([opts js]),
   :doc
   "Write or copy a JavaScript file to output directory. Only write if the file\ndoes not already exist. Return IJavaScript for the file on disk at the new\nlocation.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/write-javascript"}
  {:raw-source-url nil,
   :name "write-js?",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 1664,
   :var-type "function",
   :arglists ([js]),
   :doc
   "Returns true if IJavaScript instance needs to be written/copied to output\ndirectory. True when in memory, in a JAR, or if foreign library.",
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/write-js?"}
  {:name "JavaScriptFile",
   :var-type "record",
   :namespace "cljs.closure",
   :arglists nil,
   :wiki-url "/cljs.closure-api.html#cljs.closure/JavaScriptFile",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "Compilable",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 430,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/Compilable"}
  {:raw-source-url nil,
   :name "ISourceMap",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 347,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/ISourceMap"}
  {:raw-source-url nil,
   :name "Inputs",
   :file "src/main/clojure/cljs/closure.clj",
   :source-url nil,
   :line 421,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.closure",
   :wiki-url "/cljs.closure-api.html#cljs.closure/Inputs"}
  {:name "-compile",
   :doc "Returns one or more IJavaScripts.",
   :var-type "function",
   :namespace "cljs.closure",
   :arglists ([this opts]),
   :wiki-url "/cljs.closure-api.html#cljs.closure/-compile",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-find-sources",
   :doc "Returns one or more IJavascripts, without compiling them.",
   :var-type "function",
   :namespace "cljs.closure",
   :arglists ([this opts]),
   :wiki-url "/cljs.closure-api.html#cljs.closure/-find-sources",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-source-map",
   :doc "Return the CLJS compiler generated JS source mapping",
   :var-type "function",
   :namespace "cljs.closure",
   :arglists ([this]),
   :wiki-url "/cljs.closure-api.html#cljs.closure/-source-map",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-source-url",
   :doc "Return the CLJS source url",
   :var-type "function",
   :namespace "cljs.closure",
   :arglists ([this]),
   :wiki-url "/cljs.closure-api.html#cljs.closure/-source-url",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-paths",
   :doc "Returns the file paths to the source inputs",
   :var-type "function",
   :namespace "cljs.closure",
   :arglists ([this]),
   :wiki-url "/cljs.closure-api.html#cljs.closure/-paths",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "cljs-files-in",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 1390,
   :var-type "function",
   :arglists ([dir]),
   :doc
   "Return a sequence of all .cljs and .cljc files in the given directory.",
   :namespace "cljs.compiler",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler/cljs-files-in"}
  {:raw-source-url nil,
   :name "compile-file",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 1332,
   :var-type "function",
   :arglists ([src] [src dest] [src dest opts]),
   :doc
   "Compiles src to a file of the same name, but with a .js extension,\nin the src file's directory.\n\nWith dest argument, write file to provided location. If the dest\nargument is a file outside the source tree, missing parent\ndirectories will be created. The src file will only be compiled if\nthe dest file has an older modification time.\n\nBoth src and dest may be either a String or a File.\n\nReturns a map containing {:ns .. :provides .. :requires .. :file ..}.\nIf the file was not compiled returns only {:file ...}",
   :namespace "cljs.compiler",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler/compile-file"}
  {:raw-source-url nil,
   :name "compile-root",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 1402,
   :var-type "function",
   :arglists
   ([src-dir] [src-dir target-dir] [src-dir target-dir opts]),
   :doc
   "Looks recursively in src-dir for .cljs files and compiles them to\n.js files. If target-dir is provided, output will go into this\ndirectory mirroring the source directory structure. Returns a list\nof maps containing information about each file which was compiled\nin dependency order.",
   :namespace "cljs.compiler",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler/compile-root"}
  {:raw-source-url nil,
   :name "emit-arguments-to-array",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 699,
   :var-type "function",
   :arglists ([startslice]),
   :doc
   "Emit code that copies function arguments into an array starting at an index.\nReturns name of var holding the array.",
   :namespace "cljs.compiler",
   :wiki-url
   "/cljs.compiler-api.html#cljs.compiler/emit-arguments-to-array"}
  {:raw-source-url nil,
   :name "emit-comment",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 563,
   :var-type "function",
   :arglists ([doc jsdoc] [env doc jsdoc]),
   :doc "Emit a nicely formatted comment string.",
   :namespace "cljs.compiler",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler/emit-comment"}
  {:raw-source-url nil,
   :name "rename-to-js",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 1127,
   :var-type "function",
   :arglists ([file-str]),
   :doc
   "Change the file extension from .cljs to .js. Takes a File or a\nString. Always returns a String.",
   :namespace "cljs.compiler",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler/rename-to-js"}
  {:raw-source-url nil,
   :name "requires-compilation?",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 1309,
   :var-type "function",
   :arglists ([src dest] [src dest opts]),
   :doc "Return true if the src file requires compilation.",
   :namespace "cljs.compiler",
   :wiki-url
   "/cljs.compiler-api.html#cljs.compiler/requires-compilation?"}
  {:raw-source-url nil,
   :name "with-core-cljs",
   :file "src/main/clojure/cljs/compiler.cljc",
   :source-url nil,
   :line 1145,
   :var-type "function",
   :arglists ([] [opts] [opts body]),
   :doc "Ensure that core.cljs has been loaded.",
   :namespace "cljs.compiler",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler/with-core-cljs"}
  {:raw-source-url nil,
   :name "->",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 1586,
   :var-type "macro",
   :arglists ([x & forms]),
   :doc
   "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/->"}
  {:raw-source-url nil,
   :name "->>",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 1602,
   :var-type "macro",
   :arglists ([x & forms]),
   :doc
   "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/->>"}
  {:raw-source-url nil,
   :name "..",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 1568,
   :var-type "macro",
   :arglists ([x form] [x form & more]),
   :doc
   "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/.."}
  {:raw-source-url nil,
   :name "amap",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2487,
   :var-type "macro",
   :arglists ([a idx ret expr]),
   :doc
   "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting\neach element of ret to the evaluation of expr, returning the new\narray ret.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/amap"}
  {:raw-source-url nil,
   :name "and",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 803,
   :var-type "macro",
   :arglists ([] [x] [x & next]),
   :doc
   "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/and"}
  {:raw-source-url nil,
   :name "areduce",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2502,
   :var-type "macro",
   :arglists ([a idx ret init expr]),
   :doc
   "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the\nevaluation of expr at each step, returning ret.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/areduce"}
  {:raw-source-url nil,
   :name "as->",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 7274,
   :var-type "macro",
   :arglists ([expr name & forms]),
   :doc
   "Binds name to expr, evaluates the first form in the lexical context\nof that binding, then binds name to that result, repeating for each\nsuccessive form, returning the result of the last form.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/as->"}
  {:raw-source-url nil,
   :name "assert",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2216,
   :var-type "macro",
   :arglists ([x] [x message]),
   :doc
   "Evaluates expr and throws an exception if it does not evaluate to\nlogical true.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/assert"}
  {:raw-source-url nil,
   :name "binding",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2068,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/binding"}
  {:raw-source-url nil,
   :name "case",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2145,
   :var-type "macro",
   :arglists ([e & clauses]),
   :doc
   "Takes an expression, and a set of clauses.\n\nEach clause can take the form of either:\n\ntest-constant result-expr\n\n(test-constant1 ... test-constantN)  result-expr\n\nThe test-constants are not evaluated. They must be compile-time\nliterals, and need not be quoted.  If the expression is equal to a\ntest-constant, the corresponding result-expr is returned. A single\ndefault expression can follow the clauses, and its value will be\nreturned if no clause matches. If no default expression is provided\nand no clause matches, an Error is thrown.\n\nUnlike cond and condp, case does a constant-time dispatch, the\nclauses are not considered sequentially.  All manner of constant\nexpressions are acceptable in case, including numbers, strings,\nsymbols, keywords, and (ClojureScript) composites thereof. Note that since\nlists are used to group multiple constants that map to the same\nexpression, a vector can be used to match a list if needed. The\ntest-constants need not be all of the same type.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/case"}
  {:raw-source-url nil,
   :name "comment",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 4555,
   :var-type "macro",
   :arglists ([& body]),
   :doc "Ignores body, yields nil",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/comment"}
  {:raw-source-url nil,
   :name "cond",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 580,
   :var-type "macro",
   :arglists ([& clauses]),
   :doc
   "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/cond"}
  {:raw-source-url nil,
   :name "cond->",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 7240,
   :var-type "macro",
   :arglists ([expr & clauses]),
   :doc
   "Takes an expression and a set of test/form pairs. Threads expr (via ->)\nthrough each form for which the corresponding test\nexpression is true. Note that, unlike cond branching, cond-> threading does\nnot short circuit after the first true test expression.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/cond->"}
  {:raw-source-url nil,
   :name "cond->>",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 7257,
   :var-type "macro",
   :arglists ([expr & clauses]),
   :doc
   "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\nthrough each form for which the corresponding test expression\nis true.  Note that, unlike cond branching, cond->> threading does not short circuit\nafter the first true test expression.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/cond->>"}
  {:raw-source-url nil,
   :added "1.0",
   :name "condp",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2081,
   :var-type "macro",
   :arglists ([pred expr & clauses]),
   :doc
   "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/condp"}
  {:raw-source-url nil,
   :name "declare",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 2667,
   :var-type "macro",
   :arglists ([& names]),
   :doc
   "defs the supplied var names with no bindings, useful for making forward declarations.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/declare"}
  {:raw-source-url nil,
   :name "defmacro",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2954,
   :var-type "macro",
   :arglists
   ([name doc-string? attr-map? [params*] body]
    [name doc-string? attr-map? ([params*] body) + attr-map?]),
   :doc
   "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defmacro"}
  {:raw-source-url nil,
   :name "defmethod",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2583,
   :var-type "macro",
   :arglists ([multifn dispatch-val & fn-tail]),
   :doc
   "Creates and installs a new method of multimethod associated with dispatch-value. ",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defmethod"}
  {:raw-source-url nil,
   :name "defmulti",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2537,
   :var-type "macro",
   :arglists ([mm-name & options]),
   :doc
   "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defmulti"}
  {:raw-source-url nil,
   :name "defn",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2879,
   :var-type "macro",
   :arglists
   ([name doc-string? attr-map? [params*] prepost-map? body]
    [name
     doc-string?
     attr-map?
     ([params*] prepost-map? body)
     +
     attr-map?]),
   :doc
   "Same as (def name (core/fn [params* ] exprs*)) or (def\nname (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\nto the var metadata. prepost-map defines a map with optional keys\n:pre and :post that contain collections of pre or post conditions.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defn"}
  {:raw-source-url nil,
   :name "defn-",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 4743,
   :var-type "macro",
   :arglists ([name & decls]),
   :doc "same as defn, yielding non-public def",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defn-"}
  {:raw-source-url nil,
   :name "defonce",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 603,
   :var-type "macro",
   :arglists ([x init]),
   :doc
   "defs name to have the root value of init iff the named var has no root value,\nelse init is unevaluated",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defonce"}
  {:raw-source-url nil,
   :name "defprotocol",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1862,
   :var-type "macro",
   :arglists ([psym & doc+methods]),
   :doc
   "A protocol is a named set of named methods and their signatures:\n\n(defprotocol AProtocolName\n  ;optional doc string\n  \"A doc string for AProtocol abstraction\"\n\n;method signatures\n  (bar [this a b] \"bar docs\")\n  (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\nNo implementations are provided. Docs can be specified for the\nprotocol overall and for each method. The above yields a set of\npolymorphic functions and a protocol object. All are\nnamespace-qualified by the ns enclosing the definition The resulting\nfunctions dispatch on the type of their first argument, which is\nrequired and corresponds to the implicit target object ('this' in\nJavaScript parlance). defprotocol is dynamic, has no special compile-time\neffect, and defines no new types.\n\n(defprotocol P\n  (foo [this])\n  (bar-me [this] [this y]))\n\n(deftype Foo [a b c]\n  P\n  (foo [this] a)\n  (bar-me [this] b)\n  (bar-me [this y] (+ c y)))\n\n(bar-me (Foo. 1 2 3) 42)\n=> 45\n\n(foo\n  (let [x 42]\n    (reify P\n      (foo [this] 17)\n      (bar-me [this] x)\n      (bar-me [this y] x))))\n=> 17",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defprotocol"}
  {:raw-source-url nil,
   :name "defrecord",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1793,
   :var-type "macro",
   :arglists ([rsym fields & impls]),
   :doc
   "(defrecord name [fields*]  options* specs*)\n\nCurrently there are no options.\n\nEach spec consists of a protocol or interface name followed by zero\nor more method bodies:\n\nprotocol-or-Object\n(methodName [args*] body)*\n\nThe record will have the (immutable) fields named by\nfields, which can have type hints. Protocols and methods\nare optional. The only methods that can be supplied are those\ndeclared in the protocols.  Note that method bodies are\nnot closures, the local environment includes only the named fields,\nand those fields can be accessed directly.\n\nMethod definitions take the form:\n\n(methodname [args*] body)\n\nThe argument and return types can be hinted on the arg and\nmethodname symbols. If not supplied, they will be inferred, so type\nhints should be reserved for disambiguation.\n\nMethods should be supplied for all methods of the desired\nprotocol(s). You can also define overrides for\nmethods of Object. Note that a parameter must be supplied to\ncorrespond to the target object ('this' in JavaScript parlance). Note also\nthat recur calls to the method head should *not* pass the target object, it\nwill be supplied automatically and can not be substituted.\n\nIn the method bodies, the (unqualified) name can be used to name the\nclass (for calls to new, instance? etc).\n\nThe type will have implementations of several ClojureScript\nprotocol generated automatically: IMeta/IWithMeta (metadata support) and\nIMap, etc.\n\nIn addition, defrecord will define type-and-value-based =,\nand will define ClojureScript IHash and IEquiv.\n\nTwo constructors will be defined, one taking the designated fields\nfollowed by a metadata map (nil for none) and an extension field\nmap (nil for none), and one taking only the fields (using nil for\nmeta and extension fields). Note that the field names __meta\nand __extmap are currently reserved and should not be used when\ndefining your own records.\n\nGiven (defrecord TypeName ...), two factory functions will be\ndefined: ->TypeName, taking positional parameters for the fields,\nand map->TypeName, taking a map of keywords to field values.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/defrecord"}
  {:raw-source-url nil,
   :name "deftype",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1629,
   :var-type "macro",
   :arglists ([t fields & impls]),
   :doc
   "(deftype name [fields*]  options* specs*)\n\nCurrently there are no options.\n\nEach spec consists of a protocol or interface name followed by zero\nor more method bodies:\n\nprotocol-or-Object\n(methodName [args*] body)*\n\nThe type will have the (by default, immutable) fields named by\nfields, which can have type hints. Protocols and methods\nare optional. The only methods that can be supplied are those\ndeclared in the protocols/interfaces.  Note that method bodies are\nnot closures, the local environment includes only the named fields,\nand those fields can be accessed directly. Fields can be qualified\nwith the metadata :mutable true at which point (set! afield aval) will be\nsupported in method bodies. Note well that mutable fields are extremely\ndifficult to use correctly, and are present only to facilitate the building\nof higherlevel constructs, such as ClojureScript's reference types, in\nClojureScript itself. They are for experts only - if the semantics and\nimplications of :mutable are not immediately apparent to you, you should not\nbe using them.\n\nMethod definitions take the form:\n\n(methodname [args*] body)\n\nThe argument and return types can be hinted on the arg and\nmethodname symbols. If not supplied, they will be inferred, so type\nhints should be reserved for disambiguation.\n\nMethods should be supplied for all methods of the desired\nprotocol(s). You can also define overrides for methods of Object. Note that\na parameter must be supplied to correspond to the target object\n('this' in JavaScript parlance). Note also that recur calls to the method\nhead should *not* pass the target object, it will be supplied\nautomatically and can not be substituted.\n\nIn the method bodies, the (unqualified) name can be used to name the\nclass (for calls to new, instance? etc).\n\nOne constructor will be defined, taking the designated fields.  Note\nthat the field names __meta and __extmap are currently reserved and\nshould not be used when defining your own types.\n\nGiven (deftype TypeName ...), a factory function called ->TypeName\nwill be defined, taking positional parameters for the fields",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/deftype"}
  {:raw-source-url nil,
   :name "delay",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2038,
   :var-type "macro",
   :arglists ([& body]),
   :doc
   "Takes a body of expressions and yields a Delay object that will\ninvoke the body only the first time it is forced (with force or deref/@), and\nwill cache the result and return it on all subsequent force\ncalls.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/delay"}
  {:raw-source-url nil,
   :name "doseq",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2316,
   :var-type "macro",
   :arglists ([seq-exprs & body]),
   :doc
   "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/doseq"}
  {:raw-source-url nil,
   :name "dotimes",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2513,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/dotimes"}
  {:raw-source-url nil,
   :name "doto",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 3724,
   :var-type "macro",
   :arglists ([x & forms]),
   :doc
   "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/doto"}
  {:raw-source-url nil,
   :name "exists?",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 916,
   :var-type "macro",
   :arglists ([x]),
   :doc
   "Return true if argument exists, analogous to usage of typeof operator\nin JavaScript.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/exists?"}
  {:raw-source-url nil,
   :name "extend-protocol",
   :file "src/main/clojure/clojure/core_deftype.clj",
   :source-url nil,
   :line 831,
   :var-type "macro",
   :arglists ([p & specs]),
   :doc
   "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/extend-protocol"}
  {:raw-source-url nil,
   :name "extend-type",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1521,
   :var-type "macro",
   :arglists ([type-sym & impls]),
   :doc
   "Extend a type to a series of protocols. Useful when you are\nsupplying the definitions explicitly inline. Propagates the\ntype as a type hint on the first argument of all fns.\n\ntype-sym may be\n\n * default, meaning the definitions will apply for any value,\n   unless an extend-type exists for one of the more specific\n   cases below.\n * nil, meaning the definitions will apply for the nil value.\n * any of object, boolean, number, string, array, or function,\n   indicating the definitions will apply for values of the\n   associated base JavaScript types. Note that, for example,\n   string should be used instead of js/String.\n * a JavaScript type not covered by the previous list, such\n   as js/RegExp.\n * a type defined by deftype or defrecord.\n\n(extend-type MyType\n  ICounted\n  (-count [c] ...)\n  Foo\n  (bar [x y] ...)\n  (baz ([x] ...) ([x y & zs] ...))",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/extend-type"}
  {:raw-source-url nil,
   :name "fast-path-protocol-partitions-count",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 781,
   :var-type "var",
   :arglists nil,
   :doc "total number of partitions",
   :namespace "cljs.core",
   :wiki-url
   "/cljs.core-api.html#cljs.core/fast-path-protocol-partitions-count"}
  {:raw-source-url nil,
   :name "fast-path-protocols",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 763,
   :var-type "var",
   :arglists nil,
   :doc "protocol fqn -> [partition number, bit]",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/fast-path-protocols"}
  {:raw-source-url nil,
   :name "fn",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 4357,
   :var-type "macro",
   :arglists ([& sigs]),
   :doc
   "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/fn"}
  {:raw-source-url nil,
   :name "for",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2229,
   :var-type "macro",
   :arglists ([seq-exprs body-expr]),
   :doc
   "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/for"}
  {:raw-source-url nil,
   :name "goog-define",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 697,
   :var-type "macro",
   :arglists ([sym default]),
   :doc
   "Defines a var using `goog.define`. Passed default value must be\nstring, number or boolean.\n\nDefault value can be overridden at compile time using the\ncompiler option `:closure-defines`.\n\nExample:\n  (ns your-app.core)\n  (goog-define DEBUG! false)\n  ;; can be overridden with\n  :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n  or\n  :closure-defines {'your-app.core/DEBUG! true}",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/goog-define"}
  {:raw-source-url nil,
   :name "if-let",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 1749,
   :var-type "macro",
   :arglists ([bindings then] [bindings then else & oldform]),
   :doc
   "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/if-let"}
  {:raw-source-url nil,
   :name "if-not",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 748,
   :var-type "macro",
   :arglists ([test then] [test then else]),
   :doc
   "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/if-not"}
  {:raw-source-url nil,
   :name "if-some",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 1784,
   :var-type "macro",
   :arglists ([bindings then] [bindings then else & oldform]),
   :doc
   "bindings => binding-form test\n\nIf test is not nil, evaluates then with binding-form bound to the\nvalue of test, if not, yields else",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/if-some"}
  {:raw-source-url nil,
   :name "implements?",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1974,
   :var-type "macro",
   :arglists ([psym x]),
   :doc "EXPERIMENTAL",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/implements?"}
  {:raw-source-url nil,
   :name "js-comment",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 881,
   :var-type "macro",
   :arglists ([comment]),
   :doc
   "Emit a top-level JavaScript multi-line comment. New lines will create a\nnew comment line. Comment block will be preceded and followed by a newline",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/js-comment"}
  {:raw-source-url nil,
   :name "js-debugger",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 874,
   :var-type "macro",
   :arglists ([]),
   :doc "Emit JavaScript \"debugger;\" statement",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/js-debugger"}
  {:raw-source-url nil,
   :name "js-inline-comment",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 901,
   :var-type "macro",
   :arglists ([comment]),
   :doc "Emit an inline JavaScript comment.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/js-inline-comment"}
  {:raw-source-url nil,
   :name "lazy-cat",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2654,
   :var-type "macro",
   :arglists ([& colls]),
   :doc
   "Expands to code which yields a lazy sequence of the concatenation\nof the supplied colls.  Each coll expr is not evaluated until it is\nneeded.\n\n(lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/lazy-cat"}
  {:raw-source-url nil,
   :name "lazy-seq",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2030,
   :var-type "macro",
   :arglists ([& body]),
   :doc
   "Takes a body of expressions that returns an ISeq or nil, and yields\na ISeqable object that will invoke the body only the first time seq\nis called, and will cache the result and return it on all subsequent\nseq calls.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/lazy-seq"}
  {:raw-source-url nil,
   :name "let",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 727,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/let"}
  {:raw-source-url nil,
   :name "letfn",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 6297,
   :var-type "macro",
   :arglists ([fnspecs & body]),
   :doc
   "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/letfn"}
  {:raw-source-url nil,
   :name "loop",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 739,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/loop"}
  {:raw-source-url nil,
   :name "macroexpand",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2716,
   :var-type "macro",
   :arglists ([quoted]),
   :doc
   "Repeatedly calls macroexpand-1 on form until it no longer\nrepresents a macro form, then returns it.  Note neither\nmacroexpand-1 nor macroexpand expand macros in subforms.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/macroexpand"}
  {:raw-source-url nil,
   :name "macroexpand-1",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2707,
   :var-type "macro",
   :arglists ([quoted]),
   :doc
   "If form represents a macro form, returns its expansion,\nelse returns form.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/macroexpand-1"}
  {:raw-source-url nil,
   :name "memfn",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 3741,
   :var-type "macro",
   :arglists ([name & args]),
   :doc
   "Expands into code that creates a fn that expects to be passed an\nobject and any args and calls the named instance method on the\nobject passing the args. Use when you want to treat a Java method as\na first-class fn. name may be type-hinted with the method receiver's\ntype in order to avoid reflective calls.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/memfn"}
  {:raw-source-url nil,
   :name "ns-interns",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2672,
   :var-type "macro",
   :arglists ([[quote ns]]),
   :doc "Returns a map of the intern mappings for the namespace.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/ns-interns"}
  {:raw-source-url nil,
   :name "ns-unmap",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2683,
   :var-type "macro",
   :arglists ([[quote0 ns] [quote1 sym]]),
   :doc "Removes the mappings for the symbol from the namespace.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/ns-unmap"}
  {:raw-source-url nil,
   :name "or",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 821,
   :var-type "macro",
   :arglists ([] [x] [x & next]),
   :doc
   "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/or"}
  {:raw-source-url nil,
   :name "reify",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1226,
   :var-type "macro",
   :arglists ([& impls]),
   :doc
   "reify is a macro with the following structure:\n\n(reify options* specs*)\n\n Currently there are no options.\n\n Each spec consists of the protocol name followed by zero\n or more method bodies:\n\n protocol\n (methodName [args+] body)*\n\n Methods should be supplied for all methods of the desired\n protocol(s). You can also define overrides for Object methods. Note that\n the first parameter must be supplied to correspond to the target object\n ('this' in JavaScript parlance). Note also that recur calls\n to the method head should *not* pass the target object, it will be supplied\n automatically and can not be substituted.\n\n recur works to method heads The method bodies of reify are lexical\n closures, and can refer to the surrounding local scope:\n\n (str (let [f \"foo\"]\n      (reify Object\n        (toString [this] f))))\n == \"foo\"\n\n (seq (let [f \"foo\"]\n      (reify ISeqable\n        (-seq [this] (-seq f)))))\n == (\\f \\o \\o))\n\n reify always implements IMeta and IWithMeta and transfers meta\n data of the form to the created object.\n\n (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n == {:k :v}",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/reify"}
  {:raw-source-url nil,
   :name "satisfies?",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2000,
   :var-type "macro",
   :arglists ([psym x]),
   :doc "Returns true if x satisfies the protocol",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/satisfies?"}
  {:raw-source-url nil,
   :name "simple-benchmark",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2598,
   :var-type "macro",
   :arglists
   ([bindings
     expr
     iterations
     &
     {:keys [print-fn], :or {print-fn 'println}}]),
   :doc
   "Runs expr iterations times in the context of a let expression with\nthe given bindings, then prints out the bindings and the expr\nfollowed by number of iterations and total time. The optional\nargument print-fn, defaulting to println, sets function used to\nprint the result. expr's string representation will be produced\nusing pr-str in any case.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/simple-benchmark"}
  {:raw-source-url nil,
   :name "some->",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 7286,
   :var-type "macro",
   :arglists ([expr & forms]),
   :doc
   "When expr is not nil, threads it into the first form (via ->),\nand when that result is not nil, through the next etc",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/some->"}
  {:raw-source-url nil,
   :name "some->>",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 7300,
   :var-type "macro",
   :arglists ([expr & forms]),
   :doc
   "When expr is not nil, threads it into the first form (via ->>),\nand when that result is not nil, through the next etc",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/some->>"}
  {:raw-source-url nil,
   :name "specify",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1294,
   :var-type "macro",
   :arglists ([expr & impls]),
   :doc
   "Identical to specify! but does not mutate its first argument. The first\nargument must be an ICloneable instance.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/specify"}
  {:raw-source-url nil,
   :name "specify!",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1286,
   :var-type "macro",
   :arglists ([expr & impls]),
   :doc "Identical to reify but mutates its first argument.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/specify!"}
  {:raw-source-url nil,
   :name "this-as",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 1304,
   :var-type "macro",
   :arglists ([name & body]),
   :doc
   "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/this-as"}
  {:raw-source-url nil,
   :name "time",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2588,
   :var-type "macro",
   :arglists ([expr]),
   :doc
   "Evaluates expr and prints the time it took. Returns the value of expr.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/time"}
  {:raw-source-url nil,
   :name "undefined?",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 924,
   :var-type "macro",
   :arglists ([x]),
   :doc
   "Return true if argument is identical to the JavaScript undefined value.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/undefined?"}
  {:raw-source-url nil,
   :name "unsafe-cast",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 895,
   :var-type "macro",
   :arglists ([t x]),
   :doc
   "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/unsafe-cast"}
  {:raw-source-url nil,
   :name "vswap!",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2692,
   :var-type "macro",
   :arglists ([vol f & args]),
   :doc
   "Non-atomically swaps the value of the volatile as if:\n(apply f current-value-of-vol args). Returns the value that\nwas swapped in.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/vswap!"}
  {:raw-source-url nil,
   :name "when",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 493,
   :var-type "macro",
   :arglists ([test & body]),
   :doc
   "Evaluates test. If logical true, evaluates body in an implicit do.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/when"}
  {:raw-source-url nil,
   :name "when-first",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 4444,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "bindings => x xs\n\nRoughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/when-first"}
  {:raw-source-url nil,
   :name "when-let",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 1769,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/when-let"}
  {:raw-source-url nil,
   :name "when-not",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 499,
   :var-type "macro",
   :arglists ([test & body]),
   :doc
   "Evaluates test. If logical false, evaluates body in an implicit do.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/when-not"}
  {:raw-source-url nil,
   :name "when-some",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 1804,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "bindings => binding-form test\n\nWhen test is not nil, evaluates body with binding-form bound to the\nvalue of test",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/when-some"}
  {:raw-source-url nil,
   :name "while",
   :file "src/main/clojure/clojure/core.clj",
   :source-url nil,
   :line 6087,
   :var-type "macro",
   :arglists ([test & body]),
   :doc
   "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/while"}
  {:raw-source-url nil,
   :name "with-out-str",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2643,
   :var-type "macro",
   :arglists ([& body]),
   :doc
   "Evaluates exprs in a context in which *print-fn* is bound to .append\non a fresh StringBuffer.  Returns the string created by any nested\nprinting calls.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/with-out-str"}
  {:raw-source-url nil,
   :name "with-redefs",
   :file "src/main/clojure/cljs/core.cljc",
   :source-url nil,
   :line 2046,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "binding => var-symbol temp-value-expr\n\nTemporarily redefines vars while executing the body.  The\ntemp-value-exprs will be evaluated and each resulting value will\nreplace in parallel the root value of its var.  After the body is\nexecuted, the root values of all the vars will be set back to their\nold values. Useful for mocking out functions during testing.",
   :namespace "cljs.core",
   :wiki-url "/cljs.core-api.html#cljs.core/with-redefs"}
  {:raw-source-url nil,
   :name "with-compiler-env",
   :file "src/main/clojure/cljs/env.cljc",
   :source-url nil,
   :line 50,
   :var-type "macro",
   :arglists ([env & body]),
   :doc
   "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\nthis namespace.",
   :namespace "cljs.env",
   :wiki-url "/cljs.env-api.html#cljs.env/with-compiler-env"}
  {:raw-source-url nil,
   :name "build-index",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 122,
   :var-type "function",
   :arglists ([deps]),
   :doc
   "Index a list of dependencies by namespace and file name. There can\nbe zero or more namespaces provided per file. Upstream foreign libraies\nwill have their options merged with local foreign libraries to support\nfine-grained overriding.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/build-index"}
  {:raw-source-url nil,
   :name "dependency-order",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 170,
   :var-type "function",
   :arglists ([coll]),
   :doc "Topologically sort a collection of dependencies.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/dependency-order"}
  {:raw-source-url nil,
   :name "find-classpath-lib",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 301,
   :var-type "function",
   :arglists ([lib]),
   :doc
   "Given [lib], a string or symbol naming a goog-style JavaScript library\n(i.e. one that uses goog.provide and goog.require), look for a resource on the\nclasspath corresponding to [lib] and return a map via `library-graph-node`\nthat contains its relevant metadata.  The library found on the classpath\n_must_ contain a `goog.provide` that matches [lib], or this fn will return nil\nand print a warning.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/find-classpath-lib"}
  {:raw-source-url nil,
   :name "find-js-classpath",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 60,
   :var-type "function",
   :arglists ([path]),
   :doc
   "Returns a seq of URLs of all JavaScript files on the classpath.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/find-js-classpath"}
  {:raw-source-url nil,
   :name "find-js-fs",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 53,
   :var-type "function",
   :arglists ([path]),
   :doc "finds js resources from a path on the files system",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/find-js-fs"}
  {:raw-source-url nil,
   :name "find-js-jar",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 36,
   :var-type "function",
   :arglists ([jar-path lib-path]),
   :doc
   "Returns a seq of URLs of all JavaScript resources in the given jar",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/find-js-jar"}
  {:raw-source-url nil,
   :name "find-url",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 186,
   :var-type "function",
   :arglists ([path-or-url]),
   :doc
   "Given a string, returns a URL. Attempts to resolve as a classpath-relative\npath, then as a path relative to the working directory or a URL string",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/find-url"}
  {:raw-source-url nil,
   :name "goog-dependencies*",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 269,
   :var-type "function",
   :arglists ([]),
   :doc
   "Create an index of Google dependencies by namespace and file name.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/goog-dependencies*"}
  {:raw-source-url nil,
   :name "js-dependency-index",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 289,
   :var-type "function",
   :arglists ([opts]),
   :doc
   "Returns the index for all JavaScript dependencies. Lookup by\nnamespace or file name.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/js-dependency-index"}
  {:raw-source-url nil,
   :name "load-foreign-library*",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 196,
   :var-type "function",
   :arglists ([lib-spec] [lib-spec cp-only?]),
   :doc
   "Given a library spec (a map containing the keys :file\nand :provides), returns a map containing :provides, :requires, :file\nand :url",
   :namespace "cljs.js-deps",
   :wiki-url
   "/cljs.js-deps-api.html#cljs.js-deps/load-foreign-library*"}
  {:raw-source-url nil,
   :name "load-library*",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 224,
   :var-type "function",
   :arglists ([path]),
   :doc
   "Given a path to a JavaScript library, which is a directory\ncontaining Javascript files, return a list of maps\ncontaining :provides, :requires, :file and :url.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/load-library*"}
  {:raw-source-url nil,
   :name "parse-js-ns",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 91,
   :var-type "function",
   :arglists ([lines]),
   :doc
   "Given the lines from a JavaScript source file, parse the provide\nand require statements and return them in a map. Assumes that all\nprovide and require statements appear before the first function\ndefinition.",
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/parse-js-ns"}
  {:raw-source-url nil,
   :name "IJavaScript",
   :file "src/main/clojure/cljs/js_deps.cljc",
   :source-url nil,
   :line 111,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.js-deps",
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/IJavaScript"}
  {:name "-closure-lib?",
   :doc "Whether the Javascript represents a Closure style\nlibrary",
   :var-type "function",
   :namespace "cljs.js-deps",
   :arglists ([this]),
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/-closure-lib?",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-foreign?",
   :doc
   "Whether the Javascript represents a foreign\nlibrary (a js file that not have any goog.provide statement",
   :var-type "function",
   :namespace "cljs.js-deps",
   :arglists ([this]),
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/-foreign?",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-provides",
   :doc "A list of namespaces that this JavaScript provides.",
   :var-type "function",
   :namespace "cljs.js-deps",
   :arglists ([this]),
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/-provides",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-requires",
   :doc "A list of namespaces that this JavaScript requires.",
   :var-type "function",
   :namespace "cljs.js-deps",
   :arglists ([this]),
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/-requires",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-source",
   :doc "The JavaScript source string.",
   :var-type "function",
   :namespace "cljs.js-deps",
   :arglists ([this]),
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/-source",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-url",
   :doc
   "The URL where this JavaScript is located. Returns nil\nwhen JavaScript exists in memory only.",
   :var-type "function",
   :namespace "cljs.js-deps",
   :arglists ([this]),
   :wiki-url "/cljs.js-deps-api.html#cljs.js-deps/-url",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "formatter",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 117,
   :var-type "macro",
   :arglists ([format-in]),
   :doc
   "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/formatter"}
  {:raw-source-url nil,
   :name "formatter-out",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 133,
   :var-type "macro",
   :arglists ([format-in]),
   :doc
   "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/formatter-out"}
  {:raw-source-url nil,
   :name "getf",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 27,
   :var-type "macro",
   :arglists ([sym]),
   :doc
   "Get the value of the field a named by the argument (which should be a keyword).",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/getf"}
  {:raw-source-url nil,
   :added "1.2",
   :name "pp",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 153,
   :var-type "macro",
   :arglists ([]),
   :doc
   "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/pp"}
  {:raw-source-url nil,
   :name "pprint-logical-block",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 57,
   :var-type "macro",
   :arglists ([& args]),
   :doc
   "Execute the body as a pretty printing logical block with output to *out* which\nmust be a pretty printing writer. When used from pprint or cl-format, this can be\nassumed.\n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix\nand :suffix.",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/pprint-logical-block"}
  {:raw-source-url nil,
   :name "print-length-loop",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 92,
   :var-type "macro",
   :arglists ([bindings & body]),
   :doc
   "A version of loop that iterates at most *print-length* times. This is designed\nfor use in pretty-printer dispatch functions.",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/print-length-loop"}
  {:raw-source-url nil,
   :name "setf",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 34,
   :var-type "macro",
   :arglists ([sym new-val]),
   :doc "Set the value of the field SYM to NEW-VAL",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/setf"}
  {:raw-source-url nil,
   :name "with-pprint-dispatch",
   :file "src/main/cljs/cljs/pprint.clj",
   :source-url nil,
   :line 147,
   :var-type "macro",
   :arglists ([function & body]),
   :doc
   "Execute body with the pretty print dispatch function bound to function.",
   :namespace "cljs.pprint",
   :wiki-url "/cljs.pprint-api.html#cljs.pprint/with-pprint-dispatch"}
  {:raw-source-url nil,
   :name "analyze-source",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 733,
   :var-type "function",
   :arglists ([src-dir] [src-dir opts]),
   :doc
   "Given a source directory, analyzes all .cljs files. Used to populate\n(:cljs.analyzer/namespaces compiler-env) so as to support code reflection.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/analyze-source"}
  {:raw-source-url nil,
   :name "apropos",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 1269,
   :var-type "macro",
   :arglists ([str-or-pattern]),
   :doc
   "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/apropos"}
  {:raw-source-url nil,
   :name "dir",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 1286,
   :var-type "macro",
   :arglists ([ns]),
   :doc "Prints a sorted directory of public vars in a namespace",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/dir"}
  {:raw-source-url nil,
   :name "doc",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 1166,
   :var-type "macro",
   :arglists ([name]),
   :doc
   "Prints documentation for a var or special form given its name",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/doc"}
  {:raw-source-url nil,
   :name "evaluate-form",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 440,
   :var-type "function",
   :arglists
   ([repl-env env filename form]
    [repl-env env filename form wrap]
    [repl-env env filename form wrap opts]),
   :doc
   "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/evaluate-form"}
  {:raw-source-url nil,
   :name "find-doc",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 1202,
   :var-type "macro",
   :arglists ([re-string-or-pattern]),
   :doc
   "Prints documentation for any var whose documentation or name\ncontains a match for re-string-or-pattern",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/find-doc"}
  {:raw-source-url nil,
   :name "js-src->cljs-src",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 219,
   :var-type "function",
   :arglists ([f]),
   :doc
   "Map a JavaScript output file back to the original ClojureScript source\nfile (.cljs or .cljc).",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/js-src->cljs-src"}
  {:raw-source-url nil,
   :name "known-repl-opts",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 40,
   :var-type "var",
   :arglists nil,
   :doc "Set of all known REPL options.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/known-repl-opts"}
  {:raw-source-url nil,
   :name "load-namespace",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 176,
   :var-type "function",
   :arglists ([repl-env ns] [repl-env ns opts]),
   :doc
   "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/load-namespace"}
  {:raw-source-url nil,
   :name "mapped-stacktrace",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 322,
   :var-type "function",
   :arglists ([stacktrace] [stacktrace opts]),
   :doc
   "Given a vector representing the canonicalized JavaScript stacktrace\nreturn the ClojureScript stacktrace. The canonical stacktrace must be\nin the form:\n\n [{:file <string>\n   :function <string>\n   :line <integer>\n   :column <integer>}*]\n\n:file must be a URL path (without protocol) relative to :output-dir or a\nidentifier delimited by angle brackets. The returned mapped stacktrace will\nalso contain :url entries to the original sources if it can be determined\nfrom the classpath.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/mapped-stacktrace"}
  {:raw-source-url nil,
   :name "ns-info",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 253,
   :var-type "function",
   :arglists ([f]),
   :doc
   "Given a path to a js source file return the ns info for the corresponding\nClojureScript file if it exists.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/ns-info"}
  {:raw-source-url nil,
   :name "print-mapped-stacktrace",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 352,
   :var-type "function",
   :arglists ([stacktrace] [stacktrace opts]),
   :doc
   "Given a vector representing the canonicalized JavaScript stacktrace\nprint the ClojureScript stacktrace. See mapped-stacktrace.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/print-mapped-stacktrace"}
  {:raw-source-url nil,
   :name "read-source-map",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 233,
   :var-type "function",
   :arglists ([f]),
   :doc "Return the source map for the JavaScript source file.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/read-source-map"}
  {:raw-source-url nil,
   :name "repl",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 930,
   :var-type "function",
   :arglists ([repl-env & opts]),
   :doc
   "Generic, reusable, read-eval-print loop. By default, reads from *in* using\na c.t.r.reader-types/source-logging-push-back-reader,\nwrites to *out*, and prints exception summaries to *err*. If you use the\ndefault :read hook, *in* must either be an instance of\nc.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\nunread and collapsing CR, LF, and CRLF into a single \\newline. Options\nare sequential keyword-value pairs. The first argument is the JavaScript\nevaluation environment, the second argument is an extended version of the\nstandard ClojureScript compiler options. In addition to ClojureScript compiler\nbuild options it also take a set of options similar to clojure.main/repl with\nadjustments for ClojureScript evalution and compilation model:\n\nAvailable clojure.main/repl style options and their defaults:\n\n   - :init, function of no arguments, initialization hook called with\n     bindings for set!-able vars in place.\n     default: #()\n\n   - :need-prompt, function of no arguments, called before each\n     read-eval-print except the first, the user will be prompted if it\n     returns true.\n     default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                 (== (c.t.r.reader-types/get-column-number *in*) 1)\n                 (identity true))\n\n   - :prompt, function of no arguments, prompts for more input.\n     default: repl-prompt\n\n   - :flush, function of no arguments, flushes output\n     default: flush\n\n   - :read, function of two arguments, reads from *in*:\n       - returns its first argument to request a fresh prompt\n         - depending on need-prompt, this may cause the repl to prompt\n           before reading again\n       - returns its second argument to request an exit from the repl\n       - else returns the next object read from the input stream\n     default: repl-read\n\n   - :eval, function of one argument, returns the evaluation of its\n     argument. The eval function must take repl-env, the JavaScript evaluation\n     environment, env, the ClojureScript analysis environment, the form\n     and opts, the standard ClojureScript REPL/compiler options.\n     default: eval\n\n   - :print, function of one argument, prints its argument to the output\n     default: println\n\n   - :caught, function of three arguments, a throwable, called when\n     read, eval, or print throws an exception or error default. The second\n     argument is the JavaScript evaluation environment this permits context\n     sensitive handling if necessary. The third argument is opts, the standard\n     ClojureScript REPL/compiler options. In the case of errors or exception\n     in the JavaScript target, these will be thrown as\n     clojure.lang.IExceptionInfo instances.\n     default: repl-caught\n\n   - :reader, the c.t.r reader to use.\n     default: c.t.r.reader-types/source-logging-push-back-reader\n\n   - :print-no-newline, print without a newline.\n     default: print\n\n   - :source-map-inline, whether inline source maps should be enabled. Most\n     useful in browser context. Implies using a fresh reader for each form.\n     default: true",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/repl"}
  {:raw-source-url nil,
   :name "repl-read",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 87,
   :var-type "function",
   :arglists
   ([request-prompt request-exit] [request-prompt request-exit opts]),
   :doc
   "Default :read hook for repl. Reads from *in* which must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF into a single\n\\newline. repl-read:\n  - skips whitespace, then\n    - returns request-prompt on start of line, or\n    - returns request-exit on end of stream, or\n    - reads an object from the input stream, then\n      - skips the next input character if it's end of line, then\n      - returns the object.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/repl-read"}
  {:raw-source-url nil,
   :name "skip-if-eol",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 54,
   :var-type "function",
   :arglists ([s]),
   :doc
   "If the next character on stream s is a newline, skips it, otherwise\nleaves the stream untouched. Returns :line-start, :stream-end, or :body\nto indicate the relative location of the next character on s. The stream\nmust either be an instance of LineNumberingPushbackReader or duplicate\nits behavior of both supporting .unread and collapsing all of CR, LF, and\nCRLF to a single \\newline.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/skip-if-eol"}
  {:raw-source-url nil,
   :name "skip-whitespace",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 68,
   :var-type "function",
   :arglists ([s]),
   :doc
   "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\nor :body to indicate the relative location of the next character on s.\nInterprets comma as whitespace and semicolon as comment to end of line.\nDoes not interpret #! as comment to end of line because only one\ncharacter of lookahead is available. The stream must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF to a single\n\\newline.",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/skip-whitespace"}
  {:raw-source-url nil,
   :name "source",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 1260,
   :var-type "macro",
   :arglists ([n]),
   :doc
   "Prints the source code for the given symbol, if it can find it.\nThis requires that the symbol resolve to a Var defined in a\nnamespace for which the .cljs is in the classpath.\n\nExample: (source filter)",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/source"}
  {:raw-source-url nil,
   :name "source-fn",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 1226,
   :var-type "function",
   :arglists ([env x]),
   :doc
   "Returns a string of the source code for the given symbol, if it can\nfind it.  This requires that the symbol resolve to a Var defined in\na namespace for which the .clj is in the classpath.  Returns nil if\nit can't find the source.  For most REPL usage, 'source' is more\nconvenient.\n\nExample: (source-fn 'filter)",
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/source-fn"}
  {:raw-source-url nil,
   :name "IGetError",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 132,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/IGetError"}
  {:raw-source-url nil,
   :name "IJavaScriptEnv",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 116,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/IJavaScriptEnv"}
  {:raw-source-url nil,
   :name "IParseError",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 127,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/IParseError"}
  {:raw-source-url nil,
   :name "IParseStacktrace",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 144,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/IParseStacktrace"}
  {:raw-source-url nil,
   :name "IPrintStacktrace",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 159,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/IPrintStacktrace"}
  {:raw-source-url nil,
   :name "IReplEnvOptions",
   :file "src/main/clojure/cljs/repl.cljc",
   :source-url nil,
   :line 113,
   :var-type "protocol",
   :arglists nil,
   :doc nil,
   :namespace "cljs.repl",
   :wiki-url "/cljs.repl-api.html#cljs.repl/IReplEnvOptions"}
  {:name "-get-error",
   :doc
   "Given a symbol representing a var holding an error, an analysis\n environment, and the REPL/compiler options return the canonical error\n representation:\n\n {:value <string>\n  :stacktrace <string>}\n\n:value should be the host environment JavaScript error message string.\n:stacktrace should be the host JavaScript environment stacktrace string.",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env name env build-options]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-get-error",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-evaluate",
   :doc "evaluate a javascript string",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env filename line js]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-evaluate",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-load",
   :doc "load code at url into the environment",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env provides url]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-load",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-setup",
   :doc "initialize the environment",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env opts]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-setup",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-tear-down",
   :doc "dispose of the environment",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-tear-down",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-parse-error",
   :doc
   "Given the original JavaScript error return the error to actually\nuse.",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env error build-options]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-parse-error",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-parse-stacktrace",
   :doc
   "Given the original JavaScript stacktrace string, the entire original error\nvalue and current compiler build options, parse the stacktrace into the\ncanonical form:\n\n[{:file <string>\n  :function <string>\n  :line <integer>\n  :column <integer>}*]\n\n:file must be a URL path (without protocol) relative to :output-dir. If\nno source file can be supplied (such as REPL defs), :file may be a custom\nidentifier string surrounded by angle brackets, i.e. \"<cljs repl>\".",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env stacktrace error build-options]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-parse-stacktrace",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-print-stacktrace",
   :doc
   "Implementing REPL evaluation environments are given the opportunity to\nprint the mapped stacktrace themselves. This permits further processing.",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env stacktrace error build-options]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-print-stacktrace",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:name "-repl-options",
   :doc "Return default REPL options for a REPL Env",
   :var-type "function",
   :namespace "cljs.repl",
   :arglists ([repl-env]),
   :wiki-url "/cljs.repl-api.html#cljs.repl/-repl-options",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "decode",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 143,
   :var-type "function",
   :arglists ([source-map] [mappings source-map]),
   :doc
   "Convert a v3 source map JSON object into a nested sorted map\norganized as file, line, and column. Note this source map\nmaps from *generated* source location to original source\nlocation.",
   :namespace "cljs.source-map",
   :wiki-url "/cljs.source-map-api.html#cljs.source-map/decode"}
  {:raw-source-url nil,
   :name "decode-reverse",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 98,
   :var-type "function",
   :arglists ([source-map] [mappings source-map]),
   :doc
   "Convert a v3 source map JSON object into a nested sorted map \norganized as file, line, and column. Note this source map\nmaps from *original* source location to generated source location.",
   :namespace "cljs.source-map",
   :wiki-url
   "/cljs.source-map-api.html#cljs.source-map/decode-reverse"}
  {:raw-source-url nil,
   :name "encode",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 280,
   :var-type "function",
   :arglists ([m opts]),
   :doc
   "Take an internal source map representation represented as nested\nsorted maps of file, line, column and return a source map v3 JSON\nstring.",
   :namespace "cljs.source-map",
   :wiki-url "/cljs.source-map-api.html#cljs.source-map/encode"}
  {:raw-source-url nil,
   :name "encode*",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 215,
   :var-type "function",
   :arglists ([m opts]),
   :doc
   "Take an internal source map representation represented as nested\nsorted maps of file, line, column and return a v3 representation.",
   :namespace "cljs.source-map",
   :wiki-url "/cljs.source-map-api.html#cljs.source-map/encode*"}
  {:raw-source-url nil,
   :name "indexed-sources",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 34,
   :var-type "function",
   :arglists ([sources]),
   :doc
   "Take a seq of source file names and return a map from\nfile number to integer index.",
   :namespace "cljs.source-map",
   :wiki-url
   "/cljs.source-map-api.html#cljs.source-map/indexed-sources"}
  {:raw-source-url nil,
   :name "invert-reverse-map",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 323,
   :var-type "function",
   :arglists ([reverse-map]),
   :doc
   "Given a ClojureScript to JavaScript source map, invert it. Useful when\nmapping JavaScript stack traces when environment support is unavailable.",
   :namespace "cljs.source-map",
   :wiki-url
   "/cljs.source-map-api.html#cljs.source-map/invert-reverse-map"}
  {:raw-source-url nil,
   :name "lines->segs",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 173,
   :var-type "function",
   :arglists ([lines]),
   :doc
   "Take a nested sorted map encoding line and column information\nfor a file and return a vector of vectors of encoded segments.\nEach vector represents a line, and the internal vectors are segments\nrepresenting the contents of the line.",
   :namespace "cljs.source-map",
   :wiki-url "/cljs.source-map-api.html#cljs.source-map/lines->segs"}
  {:raw-source-url nil,
   :name "merge-source-maps",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 296,
   :var-type "function",
   :arglists ([cljs-map js-map]),
   :doc
   "Merge an internal source map representation of a single\nClojureScript file mapping original to generated with a\nsecond source map mapping original JS to generated JS.\nThe is to support source maps that work through multiple\ncompilation steps like Google Closure optimization passes.",
   :namespace "cljs.source-map",
   :wiki-url
   "/cljs.source-map-api.html#cljs.source-map/merge-source-maps"}
  {:raw-source-url nil,
   :name "relativize-path",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 196,
   :var-type "function",
   :arglists
   ([path
     {:keys [output-dir source-map-path source-map relpaths],
      :as opts}]),
   :doc
   "Relativize a path using :source-map-path if provided or the parent directory\notherwise.",
   :namespace "cljs.source-map",
   :wiki-url
   "/cljs.source-map-api.html#cljs.source-map/relativize-path"}
  {:raw-source-url nil,
   :name "seg->map",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 52,
   :var-type "function",
   :arglists ([seg source-map]),
   :doc
   "Take a source map segment represented as a vector\nand return a map.",
   :namespace "cljs.source-map",
   :wiki-url "/cljs.source-map-api.html#cljs.source-map/seg->map"}
  {:raw-source-url nil,
   :name "seg-combine",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 64,
   :var-type "function",
   :arglists ([seg relseg]),
   :doc
   "Combine a source map segment vector and a relative\nsource map segment vector and combine them to get\nan absolute segment posititon information as a vector.",
   :namespace "cljs.source-map",
   :wiki-url "/cljs.source-map-api.html#cljs.source-map/seg-combine"}
  {:raw-source-url nil,
   :name "source-compare",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 42,
   :var-type "function",
   :arglists ([sources]),
   :doc
   "Take a seq of source file names and return a comparator\nthat can be used to construct a sorted map.",
   :namespace "cljs.source-map",
   :wiki-url
   "/cljs.source-map-api.html#cljs.source-map/source-compare"}
  {:raw-source-url nil,
   :name "update-result",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 128,
   :var-type "function",
   :arglists ([result segmap gline]),
   :doc
   "Helper for decode. Take a source map and update it based on a\nsegment map.",
   :namespace "cljs.source-map",
   :wiki-url "/cljs.source-map-api.html#cljs.source-map/update-result"}
  {:raw-source-url nil,
   :name "update-reverse-result",
   :file "src/main/clojure/cljs/source_map.clj",
   :source-url nil,
   :line 80,
   :var-type "function",
   :arglists ([result segmap gline]),
   :doc
   "Helper for decode-reverse. Take a source map and update it\nbased on a segment map.",
   :namespace "cljs.source-map",
   :wiki-url
   "/cljs.source-map-api.html#cljs.source-map/update-reverse-result"}
  {:raw-source-url nil,
   :name "&",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 313,
   :var-type "macro",
   :arglists ([re & preds]),
   :doc
   "takes a regex op re, and predicates. Returns a regex-op that consumes\ninput as per re but subjects the resulting value to the\nconjunction of the predicates, and any conforming they might perform.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/&"}
  {:raw-source-url nil,
   :name "*",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 262,
   :var-type "macro",
   :arglists ([pred-form]),
   :doc
   "Returns a regex op that matches zero or more values matching\npred. Produces a vector of matches iff there is at least one match",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/*"}
  {:raw-source-url nil,
   :name "+",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 268,
   :var-type "macro",
   :arglists ([pred-form]),
   :doc
   "Returns a regex op that matches one or more values matching\npred. Produces a vector of matches",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/+"}
  {:raw-source-url nil,
   :name "?",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 274,
   :var-type "macro",
   :arglists ([pred-form]),
   :doc
   "Returns a regex op that matches zero or one value matching\npred. Produces a single value (not a collection) if matched.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/?"}
  {:raw-source-url nil,
   :name "alt",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 280,
   :var-type "macro",
   :arglists ([& key-pred-forms]),
   :doc
   "Takes key+pred pairs, e.g.\n\n(s/alt :even even? :small #(< % 42))\n\nReturns a regex op that returns a map entry containing the key of the\nfirst matching pred and the corresponding value. Thus the\n'key' and 'val' functions can be used to refer generically to the\ncomponents of the tagged return.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/alt"}
  {:raw-source-url nil,
   :name "and",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 182,
   :var-type "macro",
   :arglists ([& pred-forms]),
   :doc
   "Takes predicate/spec-forms, e.g.\n\n(s/and even? #(< % 42))\n\nReturns a spec that returns the conformed value. Successive\nconformed values propagate through rest of predicates.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/and"}
  {:raw-source-url nil,
   :name "cat",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 297,
   :var-type "macro",
   :arglists ([& key-pred-forms]),
   :doc
   "Takes key+pred pairs, e.g.\n\n(s/cat :e even? :o odd?)\n\nReturns a regex op that matches (all) values in sequence, returning a map\ncontaining the keys of each pred and the corresponding value.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/cat"}
  {:raw-source-url nil,
   :name "coll-of",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 235,
   :var-type "macro",
   :arglists ([pred & opts]),
   :doc
   "Returns a spec for a collection of items satisfying pred. Unlike\ngenerator will fill an empty init-coll.\n\nSame options as 'every'. conform will produce a collection\ncorresponding to :into if supplied, else will match the input collection,\navoiding rebuilding when possible.\n\nSame options as 'every'.\n\nSee also - every, map-of",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/coll-of"}
  {:raw-source-url nil,
   :name "conformer",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 321,
   :var-type "macro",
   :arglists ([f] [f unf]),
   :doc
   "takes a predicate function with the semantics of conform i.e. it should return either a\n(possibly converted) value or :cljs.spec/invalid, and returns a\nspec that uses it as a predicate/conformer. Optionally takes a\nsecond fn that does unform of result of first",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/conformer"}
  {:raw-source-url nil,
   :name "def",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 49,
   :var-type "macro",
   :arglists ([k spec-form]),
   :doc
   "Given a namespace-qualified keyword or resolveable symbol k, and a spec,\nspec-name, predicate or regex-op makes an entry in the registry mapping k to\nthe spec",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/def"}
  {:raw-source-url nil,
   :name "every",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 192,
   :var-type "macro",
   :arglists
   ([pred
     &
     {:keys
      [into
       kind
       count
       max-count
       min-count
       distinct
       gen-max
       gen-into
       gen],
      :as opts}]),
   :doc
   "takes a pred and validates collection elements against that pred.\n\nNote that 'every' does not do exhaustive checking, rather it samples\n*coll-check-limit* elements. Nor (as a result) does it do any\nconforming of elements. 'explain' will report at most *coll-error-limit*\nproblems.  Thus 'every' should be suitable for potentially large\ncollections.\n\nTakes several kwargs options that further constrain the collection:\n\n:kind - a pred/spec that the collection type must satisfy, e.g. vector?\n        (default nil) Note that if :kind is specified and :into is\n        not, this pred must generate in order for every to generate.\n:count - specifies coll has exactly this count (default nil)\n:min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n:distinct - all the elements are distinct (default nil)\n\nAnd additional args that control gen\n\n:gen-max - the maximum coll size to generate (default 20)\n:into - one of [], (), {}, #{} - the default collection to generate into\n    (default same as :kind if supplied, else []\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator\n\nSee also - coll-of, every-kv",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/every"}
  {:raw-source-url nil,
   :name "every-kv",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 225,
   :var-type "macro",
   :arglists ([kpred vpred & opts]),
   :doc
   "like 'every' but takes separate key and val preds and works on associative collections.\n\nSame options as 'every', :into defaults to {}\n\nSee also - map-of",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/every-kv"}
  {:raw-source-url nil,
   :name "exercise-fn",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 521,
   :var-type "macro",
   :arglists ([sym] [sym n] [sym n fspec]),
   :doc
   "exercises the fn named by sym (a symbol) by applying it to\nn (default 10) generated samples of its args spec. When fspec is\nsupplied its arg spec is used, and sym-or-f can be a fn.  Returns a\nsequence of tuples of [args ret]. ",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/exercise-fn"}
  {:raw-source-url nil,
   :name "fdef",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 380,
   :var-type "macro",
   :arglists ([fn-sym & specs]),
   :doc
   "Takes a symbol naming a function, and one or more of the following:\n\n:args A regex spec for the function arguments as they were a list to be\n  passed to apply - in this way, a single spec can handle functions with\n  multiple arities\n:ret A spec for the function's return value\n:fn A spec of the relationship between args and ret - the\n  value passed is {:args conformed-args :ret conformed-ret} and is\n  expected to contain predicates that relate those values\n\nQualifies fn-sym with resolve, or using *ns* if no resolution found.\nRegisters an fspec in the global registry, where it can be retrieved\nby calling get-spec with the var or full-qualified symbol.\n\nOnce registered, function specs are included in doc, checked by\ninstrument, tested by the runner clojure.spec.test/run-tests, and (if\na macro) used to explain errors during macroexpansion.\n\nNote that :fn specs require the presence of :args and :ret specs to\nconform values, and so :fn specs will be ignored if :args or :ret\nare missing.\n\nReturns the qualified fn-sym.\n\nFor example, to register function specs for the symbol function:\n\n(s/fdef clojure.core/symbol\n  :args (s/alt :separate (s/cat :ns string? :n string?)\n               :str string?\n               :sym symbol?)\n  :ret symbol?)",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/fdef"}
  {:raw-source-url nil,
   :name "fspec",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 329,
   :var-type "macro",
   :arglists ([& {:keys [args ret fn gen]}]),
   :doc
   "takes :args :ret and (optional) :fn kwargs whose values are preds\nand returns a spec whose conform/explain take a fn and validates it\nusing generative testing. The conformed value is always the fn itself.\n\nSee 'fdef' for a single operation that creates an fspec and\nregisters it, as well as a full description of :args, :ret and :fn\n\nfspecs can generate functions that validate the arguments and\nfabricate a return value compliant with the :ret spec, ignoring\nthe :fn spec if present.\n\nOptionally takes :gen generator-fn, which must be a fn of no args\nthat returns a test.check generator.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/fspec"}
  {:raw-source-url nil,
   :name "inst-in",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 444,
   :var-type "macro",
   :arglists ([start end]),
   :doc
   "Returns a spec that validates insts in the range from start\n(inclusive) to end (exclusive).",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/inst-in"}
  {:raw-source-url nil,
   :name "instrument",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 463,
   :var-type "macro",
   :arglists ([v]),
   :doc
   "Instruments the var at v, a var or symbol, to check specs\nregistered with fdef. Wraps the fn at v to check :args\nspec, if it exist, throwing an ex-info with explain-data if a\ncheck fails. Idempotent.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/instrument"}
  {:raw-source-url nil,
   :name "instrument-all",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 500,
   :var-type "macro",
   :arglists ([]),
   :doc "Call instrument for all speced-vars. Idempotent.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/instrument-all"}
  {:raw-source-url nil,
   :name "instrument-ns",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 486,
   :var-type "macro",
   :arglists ([& ns-syms]),
   :doc
   "Call instrument for all speced-vars in namespaces named\nby ns-syms. Idempotent.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/instrument-ns"}
  {:raw-source-url nil,
   :name "int-in",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 456,
   :var-type "macro",
   :arglists ([start end]),
   :doc
   "Returns a spec that validates longs in the range from start\n(inclusive) to end (exclusive).",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/int-in"}
  {:raw-source-url nil,
   :name "keys",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 105,
   :var-type "macro",
   :arglists ([& {:keys [req req-un opt opt-un gen]}]),
   :doc
   "Creates and returns a map validating spec. :req and :opt are both\nvectors of namespaced-qualified keywords. The validator will ensure\nthe :req keys are present. The :opt keys serve as documentation and\nmay be used by the generator.\n\nThe :req key vector supports 'and' and 'or' for key groups:\n\n(s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\nThere are also -un versions of :req and :opt. These allow\nyou to connect unqualified keys to specs.  In each case, fully\nqualfied keywords are passed, which name the specs, but unqualified\nkeys (with the same name component) are expected and checked at\nconform-time, and generated during gen:\n\n(s/keys :req-un [:my.ns/x :my.ns/y])\n\nThe above says keys :x and :y are required, and will be validated\nand generated by specs (if they exist) named :my.ns/x :my.ns/y\nrespectively.\n\nIn addition, the values of *all* namespace-qualified keys will be validated\n(and possibly destructured) by any registered specs. Note: there is\nno support for inline value specification, by design.\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/keys"}
  {:raw-source-url nil,
   :name "keys*",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 422,
   :var-type "macro",
   :arglists ([& kspecs]),
   :doc
   "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\nconverts them into a map, and conforms that map with a corresponding\nspec/keys call:\n\nuser=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n{:a 1, :c 2}\nuser=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n{:a 1, :c 2}\n\nthe resulting regex op can be composed into a larger regex:\n\nuser=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n{:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/keys*"}
  {:raw-source-url nil,
   :name "map-of",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 249,
   :var-type "macro",
   :arglists ([kpred vpred & opts]),
   :doc
   "Returns a spec for a map whose keys satisfy kpred and vals satisfy\nvpred. Unlike 'every-kv', map-of will exhaustively conform every\nvalue.\n\nSame options as 'every', :kind defaults to map?, with the addition of:\n\n:conform-keys - conform keys as well as values (default false)\n\nSee also - every-kv",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/map-of"}
  {:raw-source-url nil,
   :name "merge",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 512,
   :var-type "macro",
   :arglists ([& pred-forms]),
   :doc
   "Takes map-validating specs (e.g. 'keys' specs) and\nreturns a spec that returns a conformed map satisfying all of the\nspecs.  Successive conformed values propagate through rest of\npredicates. Unlike 'and', merge can generate maps satisfying the\nunion of the predicates.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/merge"}
  {:raw-source-url nil,
   :name "multi-spec",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 76,
   :var-type "macro",
   :arglists ([mm retag]),
   :doc
   "Takes the name of a spec/predicate-returning multimethod and a\ntag-restoring keyword or fn (retag).  Returns a spec that when\nconforming or explaining data will pass it to the multimethod to get\nan appropriate spec. You can e.g. use multi-spec to dynamically and\nextensibly associate specs with 'tagged' data (i.e. data where one\nof the fields indicates the shape of the rest of the structure).\n\n(defmulti mspec :tag)\n\nThe methods should ignore their argument and return a predicate/spec:\n(defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\nretag is used during generation to retag generated values with\nmatching tags. retag can either be a keyword, at which key the\ndispatch-tag will be assoc'ed, or a fn of generated value and\ndispatch-tag that should return an appropriately retagged value.\n\nNote that because the tags themselves comprise an open set,\nthe tag key spec cannot enumerate the values, but can e.g.\ntest for keyword?.\n\nNote also that the dispatch values of the multimethod will be\nincluded in the path, i.e. in reporting and gen overrides, even\nthough those values are not evident in the spec.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/multi-spec"}
  {:raw-source-url nil,
   :name "nilable",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 439,
   :var-type "macro",
   :arglists ([pred]),
   :doc "returns a spec that accepts nil and values satisfiying pred",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/nilable"}
  {:raw-source-url nil,
   :name "or",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 165,
   :var-type "macro",
   :arglists ([& key-pred-forms]),
   :doc
   "Takes key+pred pairs, e.g.\n\n(s/or :even even? :small #(< % 42))\n\nReturns a destructuring spec that returns a map entry containing the\nkey of the first matching pred and the corresponding value. Thus the\n'key' and 'val' functions can be used to refer generically to the\ncomponents of the tagged return.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/or"}
  {:raw-source-url nil,
   :name "spec",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 57,
   :var-type "macro",
   :arglists ([form & {:keys [gen]}]),
   :doc
   "Takes a single predicate form, e.g. can be the name of a predicate,\nlike even?, or a fn literal like #(< % 42). Note that it is not\ngenerally necessary to wrap predicates in spec when using the rest\nof the spec macros, only to attach a unique generator\n\nCan also be passed the result of one of the regex ops -\ncat, alt, *, +, ?, in which case it will return a regex-conforming\nspec, useful when nesting an independent regex.\n---\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator.\n\nReturns a spec.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/spec"}
  {:raw-source-url nil,
   :name "speced-vars",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 373,
   :var-type "macro",
   :arglists ([& ns-syms]),
   :doc
   "Returns the set of vars whose namespace is in ns-syms AND\nwhose vars have been speced with fdef. If no ns-syms are\nspecified, return speced vars from all namespaces.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/speced-vars"}
  {:raw-source-url nil,
   :name "tuple",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 349,
   :var-type "macro",
   :arglists ([& preds]),
   :doc
   "takes one or more preds and returns a spec for a tuple, a vector\nwhere each element conforms to the corresponding pred. Each element\nwill be referred to in paths using its ordinal.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/tuple"}
  {:raw-source-url nil,
   :name "unstrument",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 476,
   :var-type "macro",
   :arglists ([v]),
   :doc
   "Undoes instrument on the var at v, a var or symbol. Idempotent.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/unstrument"}
  {:raw-source-url nil,
   :name "unstrument-all",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 506,
   :var-type "macro",
   :arglists ([]),
   :doc "Call unstrument for all speced-vars. Idempotent",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/unstrument-all"}
  {:raw-source-url nil,
   :name "unstrument-ns",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 493,
   :var-type "macro",
   :arglists ([& ns-syms]),
   :doc
   "Call unstrument for all speced-vars in namespaces named\nby ns-syms. Idempotent.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/unstrument-ns"}
  {:raw-source-url nil,
   :name "with-instrument-disabled",
   :file "src/main/cljs/cljs/spec.cljc",
   :source-url nil,
   :line 416,
   :var-type "macro",
   :arglists ([& body]),
   :doc "Disables instrument's checking of calls, within a scope.",
   :namespace "cljs.spec",
   :wiki-url "/cljs.spec-api.html#cljs.spec/with-instrument-disabled"}
  {:raw-source-url nil,
   :name "mapped-frame",
   :file "src/main/cljs/cljs/stacktrace.cljc",
   :source-url nil,
   :line 531,
   :var-type "function",
   :arglists ([{:keys [function file line column]} sms opts]),
   :doc
   "Given opts and a canonicalized JavaScript stacktrace frame, return the\nClojureScript frame.",
   :namespace "cljs.stacktrace",
   :wiki-url "/cljs.stacktrace-api.html#cljs.stacktrace/mapped-frame"}
  {:raw-source-url nil,
   :name "mapped-line-column-call",
   :file "src/main/cljs/cljs/stacktrace.cljc",
   :source-url nil,
   :line 510,
   :var-type "function",
   :arglists ([sms file line column]),
   :doc
   "Given a cljs.source-map source map data structure map a generated line\nand column back to the original line, column, and function called.",
   :namespace "cljs.stacktrace",
   :wiki-url
   "/cljs.stacktrace-api.html#cljs.stacktrace/mapped-line-column-call"}
  {:raw-source-url nil,
   :name "mapped-stacktrace",
   :file "src/main/cljs/cljs/stacktrace.cljc",
   :source-url nil,
   :line 551,
   :var-type "function",
   :arglists ([stacktrace sms] [stacktrace sms opts]),
   :doc
   "Given a vector representing the canonicalized JavaScript stacktrace\nreturn the ClojureScript stacktrace. The canonical stacktrace must be\nin the form:\n\n [{:file <string>\n   :function <string>\n   :line <integer>\n   :column <integer>}*]\n\n:file must be a URL path (without protocol) relative to :output-dir or a\nidentifier delimited by angle brackets. The returned mapped stacktrace will\nalso contain :url entries to the original sources if it can be determined\nfrom the classpath.",
   :namespace "cljs.stacktrace",
   :wiki-url
   "/cljs.stacktrace-api.html#cljs.stacktrace/mapped-stacktrace"}
  {:raw-source-url nil,
   :name "mapped-stacktrace-str",
   :file "src/main/cljs/cljs/stacktrace.cljc",
   :source-url nil,
   :line 588,
   :var-type "function",
   :arglists ([stacktrace sms] [stacktrace sms opts]),
   :doc
   "Given a vector representing the canonicalized JavaScript stacktrace and a map\nof library names to decoded source maps, print the ClojureScript stacktrace .\nSee mapped-stacktrace.",
   :namespace "cljs.stacktrace",
   :wiki-url
   "/cljs.stacktrace-api.html#cljs.stacktrace/mapped-stacktrace-str"}
  {:raw-source-url nil,
   :name "parse-file",
   :file "src/main/cljs/cljs/stacktrace.cljc",
   :source-url nil,
   :line 81,
   :var-type "function",
   :arglists
   ([{:keys [host host-port port], :as repl-env}
     file
     {:keys [asset-path], :as opts}]),
   :doc
   "Given a browser file url convert it into a relative path that can be used\nto locate the original source.",
   :namespace "cljs.stacktrace",
   :wiki-url "/cljs.stacktrace-api.html#cljs.stacktrace/parse-file"}
  {:raw-source-url nil,
   :name "parse-stacktrace",
   :file "src/main/cljs/cljs/stacktrace.cljc",
   :source-url nil,
   :line 17,
   :var-type "multimethod",
   :arglists nil,
   :doc
   "Parse a JavaScript stacktrace string into a canonical data form. The\narguments:\n\nrepl-env - the repl environment, an optional map with :host and :port keys\n           if the stacktrace includes url, not file references\nst       - the original stacktrace string to parse\nerr      - an error map. :ua-product key defines the type of stacktrace parser\n           to use, for example :chrome\nopts     - additional options. :output-dir maybe given in this argument if\n           :host and :port do not apply, for example, a file path\n\nThe canonical stacktrace representation can easily be mapped to a\nClojureScript one see mapped-stacktrace and mapped-stacktrace-str",
   :namespace "cljs.stacktrace",
   :wiki-url
   "/cljs.stacktrace-api.html#cljs.stacktrace/parse-stacktrace"}
  {:raw-source-url nil,
   :name "assert-args",
   :file "src/main/clojure/cljs/support.cljc",
   :source-url nil,
   :line 11,
   :var-type "macro",
   :arglists ([fnname & pairs]),
   :doc "Internal - do not use!",
   :namespace "cljs.support",
   :wiki-url "/cljs.support-api.html#cljs.support/assert-args"}
  {:raw-source-url nil,
   :name "->JSValue",
   :file "src/main/clojure/cljs/tagged_literals.cljc",
   :source-url nil,
   :line 60,
   :var-type "function",
   :arglists ([val]),
   :doc
   "Positional factory function for class cljs.tagged_literals.JSValue.",
   :namespace "cljs.tagged-literals",
   :wiki-url
   "/cljs.tagged-literals-api.html#cljs.tagged-literals/->JSValue"}
  {:name "JSValue",
   :var-type "type",
   :namespace "cljs.tagged-literals",
   :arglists nil,
   :wiki-url
   "/cljs.tagged-literals-api.html#cljs.tagged-literals/JSValue",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "are",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 168,
   :var-type "macro",
   :arglists ([argv expr & args]),
   :doc
   "Checks multiple assertions with a template expression.\nSee clojure.template/do-template for an explanation of\ntemplates.\n\nExample: (are [x y] (= x y)  \n              2 (+ 1 1)\n              4 (* 2 2))\nExpands to: \n         (do (is (= 2 (+ 1 1)))\n             (is (= 4 (* 2 2))))\n\nNote: This breaks some reporting features, such as line numbers.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/are"}
  {:raw-source-url nil,
   :name "assert-any",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 45,
   :var-type "function",
   :arglists ([msg form]),
   :doc
   "Returns generic assertion code for any test, including macros, Java\nmethod calls, or isolated symbols.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/assert-any"}
  {:raw-source-url nil,
   :name "assert-predicate",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 25,
   :var-type "function",
   :arglists ([msg form]),
   :doc
   "Returns generic assertion code for any functional predicate.  The\n'expected' argument to 'report' will contains the original form, the\n'actual' argument will contain the form with all its sub-forms\nevaluated.  If the predicate returns false, the 'actual' form will\nbe wrapped in (not...).",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/assert-predicate"}
  {:raw-source-url nil,
   :name "async",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 224,
   :var-type "macro",
   :arglists ([done & body]),
   :doc
   "Wraps body as a CPS function that can be returned from a test to\ncontinue asynchronously.  Binds done to a function that must be\ninvoked once and from an async context after any assertions.\n\n(deftest example-with-timeout\n  (async done\n    (js/setTimeout (fn []\n                     ;; make assertions in async context...\n                     (done) ;; ...then call done\n                     )\n                   0)))",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/async"}
  {:raw-source-url nil,
   :name "deftest",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 206,
   :var-type "macro",
   :arglists ([name & body]),
   :doc
   "Defines a test function with no arguments.  Test functions may call\nother tests, so tests may be composed.  If you compose tests, you\nshould also define a function named test-ns-hook; run-tests will\ncall test-ns-hook instead of testing all vars.\n\nNote: Actually, the test body goes in the :test metadata on the var,\nand the real function (the value of the var) calls test-var on\nitself.\n\nWhen cljs.analyzer/*load-tests* is false, deftest is ignored.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/deftest"}
  {:raw-source-url nil,
   :name "function?",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 19,
   :var-type "function",
   :arglists ([menv x]),
   :doc
   "Returns true if argument is a function or a symbol that resolves to\na function (not a macro).",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/function?"}
  {:raw-source-url nil,
   :name "is",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 150,
   :var-type "macro",
   :arglists ([form] [form msg]),
   :doc
   "Generic assertion macro.  'form' is any predicate test.\n'msg' is an optional message to attach to the assertion.\n\nExample: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\nSpecial forms:\n\n(is (thrown? c body)) checks that an instance of c is thrown from\nbody, fails if not; then returns the thing thrown.\n\n(is (thrown-with-msg? c re body)) checks that an instance of c is\nthrown AND that the message on the exception matches (with\nre-find) the regular expression re.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/is"}
  {:raw-source-url nil,
   :name "run-all-tests",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 298,
   :var-type "macro",
   :arglists ([] [re] [re env]),
   :doc
   "Runs all tests in all namespaces; prints results.\nOptional argument is a regular expression; only namespaces with\nnames matching the regular expression (with re-matches) will be\ntested.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/run-all-tests"}
  {:raw-source-url nil,
   :name "run-tests",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 284,
   :var-type "macro",
   :arglists ([] [env-or-ns] [env-or-ns & namespaces]),
   :doc
   "Runs all tests in the given namespaces; prints results.\nDefaults to current namespace if none given. Does not return a meaningful\nvalue due to the possiblity of asynchronous execution. To detect test\ncompletion add a :end-run-tests method case to the cljs.test/report\nmultimethod.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/run-tests"}
  {:raw-source-url nil,
   :name "run-tests-block",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 249,
   :var-type "macro",
   :arglists ([env-or-ns & namespaces]),
   :doc
   "Like test-vars, but returns a block for further composition and\nlater execution.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/run-tests-block"}
  {:raw-source-url nil,
   :name "test-all-vars",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 335,
   :var-type "macro",
   :arglists ([[quote ns :as form]]),
   :doc
   "Calls test-vars on every var with :test metadata interned in the\nnamespace, with fixtures.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/test-all-vars"}
  {:raw-source-url nil,
   :name "test-ns",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 361,
   :var-type "macro",
   :arglists ([ns] [env [quote ns :as form]]),
   :doc
   "If the namespace defines a function named test-ns-hook, calls that.\nOtherwise, calls test-all-vars on the namespace.  'ns' is a\nnamespace object or a symbol.\n\nInternally binds *report-counters* to a ref initialized to\n*initial-report-counters*.  ",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/test-ns"}
  {:raw-source-url nil,
   :name "test-ns-block",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 344,
   :var-type "macro",
   :arglists ([env [quote ns :as form]]),
   :doc
   "Like test-ns, but returns a block for further composition and\nlater execution.  Does not clear the current env.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/test-ns-block"}
  {:raw-source-url nil,
   :name "testing",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 192,
   :var-type "macro",
   :arglists ([string & body]),
   :doc
   "Adds a new string to the list of testing contexts.  May be nested,\nbut must occur inside a test function (deftest).",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/testing"}
  {:raw-source-url nil,
   :name "try-expr",
   :file "src/main/cljs/cljs/test.cljc",
   :source-url nil,
   :line 136,
   :var-type "macro",
   :arglists ([msg form]),
   :doc
   "Used by the 'is' macro to catch unexpected exceptions.\nYou don't call this.",
   :namespace "cljs.test",
   :wiki-url "/cljs.test-api.html#cljs.test/try-expr"}
  {:raw-source-url nil,
   :name "clojurescript-version",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 21,
   :var-type "function",
   :arglists ([]),
   :doc "Returns clojurescript version as a printable string.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/clojurescript-version"}
  {:raw-source-url nil,
   :name "ext",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 125,
   :var-type "function",
   :arglists ([x]),
   :doc "Given a file, url or string return the file extension.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/ext"}
  {:raw-source-url nil,
   :name "get-name",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 135,
   :var-type "function",
   :arglists ([x]),
   :doc "Given a file or url return the last component of the path.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/get-name"}
  {:raw-source-url nil,
   :name "levenshtein-distance",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 213,
   :var-type "function",
   :arglists ([s t]),
   :doc
   "The the minimum number of single-element edits needed to\ntransform s in to t.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/levenshtein-distance"}
  {:raw-source-url nil,
   :added "1.0",
   :name "measure",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 190,
   :var-type "macro",
   :arglists ([msg expr] [enable msg expr]),
   :doc
   "Like cljs.core/time but toggleable and takes a message string.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/measure"}
  {:raw-source-url nil,
   :name "mkdirs",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 98,
   :var-type "function",
   :arglists ([f]),
   :doc "Create all parent directories for the passed file.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/mkdirs"}
  {:raw-source-url nil,
   :name "ns->relpath",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 52,
   :var-type "function",
   :arglists ([ns] [ns ext]),
   :doc
   "Given a namespace as a symbol return the relative path. May optionally\nprovide the file extension, defaults to :cljs.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/ns->relpath"}
  {:raw-source-url nil,
   :name "ns->source",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 59,
   :var-type "function",
   :arglists ([ns]),
   :doc
   "Given a namespace as a symbol return the corresponding resource if it exists.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/ns->source"}
  {:raw-source-url nil,
   :name "suggestion",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 230,
   :var-type "function",
   :arglists ([threshold unknown knowns]),
   :doc
   "Provides a best suggestion for an unknown, taken from knowns,\nminimizing the Levenshtein distance, returning nil if threshold\ncannot be satisfied.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/suggestion"}
  {:raw-source-url nil,
   :name "unknown-opts",
   :file "src/main/clojure/cljs/util.cljc",
   :source-url nil,
   :line 241,
   :var-type "function",
   :arglists ([passed knowns]),
   :doc
   "Takes a set of passed opt keys and known opt keys and for each\nunknown opt key returns a vector of the key and its (potentially\nnil) suggestion.",
   :namespace "cljs.util",
   :wiki-url "/cljs.util-api.html#cljs.util/unknown-opts"}
  {:raw-source-url nil,
   :name "all-ns",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 155,
   :var-type "function",
   :arglists ([] [state]),
   :doc
   "Return all namespaces. Analagous to clojure.core/all-ns but\nreturns symbols identifying namespaces not Namespace instances.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/all-ns"}
  {:raw-source-url nil,
   :name "analyze",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 69,
   :var-type "function",
   :arglists
   ([env form]
    [env form name]
    [env form name opts]
    [state env form name opts]),
   :doc
   "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n(one of :statement, :expr, :return), :ns (a symbol naming the\ncompilation ns)}, and form, returns an expression object (a map\ncontaining at least :form, :op and :env keys). If expr has any (immediately)\nnested exprs, must have :children [exprs...] entry. This will\nfacilitate code walking without knowing the details of the op set.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/analyze"}
  {:raw-source-url nil,
   :name "analyze-file",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 120,
   :var-type "function",
   :arglists ([f] [f opts] [state f opts]),
   :doc
   "Given a java.io.File, java.net.URL or a string identifying a resource on the\n   classpath attempt to analyze it.\n\n   This function side-effects the ambient compilation environment\n   `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n   compiler options, if :cache-analysis true will cache analysis to\n   \":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\n   meaningful value.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/analyze-file"}
  {:raw-source-url nil,
   :name "default-warning-handler",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 48,
   :var-type "function",
   :arglists ([warning-type env extra]),
   :doc
   "The default warning handler.\n\nOutputs the warning messages to *err*.",
   :namespace "cljs.analyzer.api",
   :wiki-url
   "/cljs.analyzer-api.html#cljs.analyzer.api/default-warning-handler"}
  {:raw-source-url nil,
   :name "empty-env",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 31,
   :var-type "function",
   :arglists ([]),
   :doc "Creates an empty analysis environment.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/empty-env"}
  {:raw-source-url nil,
   :name "empty-state",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 20,
   :var-type "function",
   :arglists ([]),
   :doc "Creates an empty compilation state Atom<Map>.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/empty-state"}
  {:raw-source-url nil,
   :name "find-ns",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 163,
   :var-type "function",
   :arglists ([sym] [state sym]),
   :doc
   "Given a namespace return the corresponding namespace analysis map. Analagous\nto clojure.core/find-ns.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/find-ns"}
  {:raw-source-url nil,
   :name "forms-seq",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 90,
   :var-type "function",
   :arglists ([rdr] [rdr filename]),
   :doc
   "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\naccepts a filename argument which will be used in any emitted errors.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/forms-seq"}
  {:raw-source-url nil,
   :name "get-js-index",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 61,
   :var-type "function",
   :arglists ([] [state]),
   :doc
   "Return the currently computed Google Closure js dependency index from the\ncompiler state.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/get-js-index"}
  {:raw-source-url nil,
   :name "get-options",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 55,
   :var-type "function",
   :arglists ([] [state]),
   :doc "Return the compiler options from compiler state.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/get-options"}
  {:raw-source-url nil,
   :name "in-cljs-user",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 213,
   :var-type "macro",
   :arglists ([env & body]),
   :doc
   "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\nenvironment atom and runs body.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/in-cljs-user"}
  {:raw-source-url nil,
   :name "no-warn",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 36,
   :var-type "macro",
   :arglists ([& body]),
   :doc "Disable analyzer warnings for any analysis executed in body.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/no-warn"}
  {:raw-source-url nil,
   :name "ns-interns",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 172,
   :var-type "function",
   :arglists ([ns] [state ns]),
   :doc
   "Given a namespace return all the var analysis maps. Analagous to\nclojure.core/ns-interns but returns var analysis maps not vars.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/ns-interns"}
  {:raw-source-url nil,
   :name "ns-publics",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 183,
   :var-type "function",
   :arglists ([ns] [state ns]),
   :doc
   "Given a namespace return all the public var analysis maps. Analagous to\nclojure.core/ns-publics but returns var analysis maps not vars.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/ns-publics"}
  {:raw-source-url nil,
   :name "ns-resolve",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 196,
   :var-type "function",
   :arglists ([ns sym] [state ns sym]),
   :doc
   "Given a namespace and a symbol return the corresponding var analysis map.\nAnalagous to clojure.core/ns-resolve but returns var analysis map not Var.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/ns-resolve"}
  {:raw-source-url nil,
   :name "parse-ns",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 97,
   :var-type "function",
   :arglists ([src] [src opts] [src dest opts] [state src dest opts]),
   :doc
   "Helper for parsing only the essential namespace information from a\n   ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n   map _not_ a namespace AST node.\n\n   By default does not load macros or perform any analysis of dependencies. If\n   opts parameter provided :analyze-deps and :load-macros keys their values will\n   be used for *analyze-deps* and *load-macros* bindings respectively. This\n   function does _not_ side-effect the ambient compilation environment unless\n   requested via opts where :restore is false.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/parse-ns"}
  {:raw-source-url nil,
   :name "remove-ns",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 205,
   :var-type "function",
   :arglists ([ns] [state ns]),
   :doc "Removes the namespace named by the symbol.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/remove-ns"}
  {:raw-source-url nil,
   :name "resolve",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 144,
   :var-type "function",
   :arglists ([env sym]),
   :doc
   "Given an analysis environment resolve a var. Analogous to\nclojure.core/resolve",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/resolve"}
  {:raw-source-url nil,
   :name "warning-enabled?",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 43,
   :var-type "function",
   :arglists ([warning-type]),
   :doc "Test if the given warning-type is enabled.",
   :namespace "cljs.analyzer.api",
   :wiki-url
   "/cljs.analyzer-api.html#cljs.analyzer.api/warning-enabled?"}
  {:raw-source-url nil,
   :name "with-state",
   :file "src/main/clojure/cljs/analyzer/api.cljc",
   :source-url nil,
   :line 25,
   :var-type "macro",
   :arglists ([state body]),
   :doc "Run the body with the given compilation state Atom<Map>.",
   :namespace "cljs.analyzer.api",
   :wiki-url "/cljs.analyzer-api.html#cljs.analyzer.api/with-state"}
  {:raw-source-url nil,
   :name "cljs-files-in",
   :file "src/main/clojure/cljs/compiler/api.clj",
   :source-url nil,
   :line 88,
   :var-type "function",
   :arglists ([dir]),
   :doc
   "Return a sequence of all .cljs and .cljc files in the given directory.",
   :namespace "cljs.compiler.api",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler.api/cljs-files-in"}
  {:raw-source-url nil,
   :name "compile-file",
   :file "src/main/clojure/cljs/compiler/api.clj",
   :source-url nil,
   :line 62,
   :var-type "function",
   :arglists ([src] [src dest] [src dest opts] [state src dest opts]),
   :doc
   "Compiles src to a file of the same name, but with a .js extension,\nin the src file's directory.\n\nWith dest argument, write file to provided location. If the dest\nargument is a file outside the source tree, missing parent\ndirectories will be created. The src file will only be compiled if\nthe dest file has an older modification time.\n\nBoth src and dest may be either a String or a File.\n\nReturns a map containing {:ns .. :provides .. :requires .. :file ..}.\nIf the file was not compiled returns only {:file ...}",
   :namespace "cljs.compiler.api",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler.api/compile-file"}
  {:raw-source-url nil,
   :name "compile-root",
   :file "src/main/clojure/cljs/compiler/api.clj",
   :source-url nil,
   :line 93,
   :var-type "function",
   :arglists
   ([src-dir]
    [src-dir target-dir]
    [src-dir target-dir opts]
    [state src-dir target-dir opts]),
   :doc
   "Looks recursively in src-dir for .cljs files and compiles them to\n.js files. If target-dir is provided, output will go into this\ndirectory mirroring the source directory structure. Returns a list\nof maps containing information about each file which was compiled\nin dependency order.",
   :namespace "cljs.compiler.api",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler.api/compile-root"}
  {:raw-source-url nil,
   :name "emit",
   :file "src/main/clojure/cljs/compiler/api.clj",
   :source-url nil,
   :line 20,
   :var-type "function",
   :arglists ([ast] [state ast]),
   :doc
   "Given an AST node generated by the analyzer emit JavaScript as a string.",
   :namespace "cljs.compiler.api",
   :wiki-url "/cljs.compiler-api.html#cljs.compiler.api/emit"}
  {:raw-source-url nil,
   :name "requires-compilation?",
   :file "src/main/clojure/cljs/compiler/api.clj",
   :source-url nil,
   :line 48,
   :var-type "function",
   :arglists ([src dest] [src dest opts] [state src dest opts]),
   :doc "Return true if the src file requires compilation.",
   :namespace "cljs.compiler.api",
   :wiki-url
   "/cljs.compiler-api.html#cljs.compiler.api/requires-compilation?"}
  {:raw-source-url nil,
   :name "with-core-cljs",
   :file "src/main/clojure/cljs/compiler/api.clj",
   :source-url nil,
   :line 33,
   :var-type "function",
   :arglists ([] [opts] [opts body] [state opts body]),
   :doc "Ensure that core.cljs has been loaded.",
   :namespace "cljs.compiler.api",
   :wiki-url
   "/cljs.compiler-api.html#cljs.compiler.api/with-core-cljs"}
  {:raw-source-url nil,
   :name "with-compiler-env",
   :file "src/main/clojure/cljs/env/macros.clj",
   :source-url nil,
   :line 13,
   :var-type "macro",
   :arglists ([env & body]),
   :doc
   "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\nthis namespace.",
   :namespace "cljs.env.macros",
   :wiki-url "/cljs.env-api.html#cljs.env.macros/with-compiler-env"}
  {:raw-source-url nil,
   :name "->BrowserEnv",
   :file "src/main/clojure/cljs/repl/browser.clj",
   :source-url nil,
   :line 253,
   :var-type "function",
   :arglists ([]),
   :doc
   "Positional factory function for class cljs.repl.browser.BrowserEnv.",
   :namespace "cljs.repl.browser",
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/->BrowserEnv"}
  {:raw-source-url nil,
   :name "browser-eval",
   :file "src/main/clojure/cljs/repl/browser.clj",
   :source-url nil,
   :line 184,
   :var-type "function",
   :arglists ([form]),
   :doc
   "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured.",
   :namespace "cljs.repl.browser",
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/browser-eval"}
  {:raw-source-url nil,
   :name "constrain-order",
   :file "src/main/clojure/cljs/repl/browser.clj",
   :source-url nil,
   :line 164,
   :var-type "function",
   :arglists ([order f]),
   :doc
   "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order.",
   :namespace "cljs.repl.browser",
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/constrain-order"}
  {:raw-source-url nil,
   :name "load-javascript",
   :file "src/main/clojure/cljs/repl/browser.clj",
   :source-url nil,
   :line 202,
   :var-type "function",
   :arglists ([repl-env provides url]),
   :doc
   "Accepts a REPL environment, a list of namespaces, and a URL for a\nJavaScript file which contains the implementation for the list of\nnamespaces. Will load the JavaScript file into the REPL environment\nif any of the namespaces have not already been loaded from the\nClojureScript REPL.",
   :namespace "cljs.repl.browser",
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/load-javascript"}
  {:raw-source-url nil,
   :name "map->BrowserEnv",
   :file "src/main/clojure/cljs/repl/browser.clj",
   :source-url nil,
   :line 253,
   :var-type "function",
   :arglists ([m#]),
   :doc
   "Factory function for class cljs.repl.browser.BrowserEnv, taking a map of keywords to field values.",
   :namespace "cljs.repl.browser",
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/map->BrowserEnv"}
  {:raw-source-url nil,
   :name "repl-env",
   :file "src/main/clojure/cljs/repl/browser.clj",
   :source-url nil,
   :line 309,
   :var-type "function",
   :arglists ([& {:as opts}]),
   :doc
   "Create a browser-connected REPL environment.\n\nOptions:\n\nport:           The port on which the REPL server will run. Defaults to 9000.\nworking-dir:    The directory where the compiled REPL client JavaScript will\n                be stored. Defaults to \".repl\" with a ClojureScript version\n                suffix, eg. \".repl-0.0-2138\".\nserve-static:   Should the REPL server attempt to serve static content?\n                Defaults to true.\nstatic-dir:     List of directories to search for static content. Defaults to\n                [\".\" \"out/\"].\noptimizations:  The level of optimization to use when compiling the client\n                end of the REPL. Defaults to :simple.\nsrc:            The source directory containing user-defined cljs files. Used to\n                support reflection. Defaults to \"src/\".\n",
   :namespace "cljs.repl.browser",
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/repl-env"}
  {:raw-source-url nil,
   :name "send-for-eval",
   :file "src/main/clojure/cljs/repl/browser.clj",
   :source-url nil,
   :line 60,
   :var-type "function",
   :arglists ([form return-value-fn] [conn form return-value-fn]),
   :doc
   "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received.",
   :namespace "cljs.repl.browser",
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/send-for-eval"}
  {:name "BrowserEnv",
   :var-type "record",
   :namespace "cljs.repl.browser",
   :arglists nil,
   :wiki-url "/cljs.repl-api.html#cljs.repl.browser/BrowserEnv",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "->NashornEnv",
   :file "src/main/clojure/cljs/repl/nashorn.clj",
   :source-url nil,
   :line 109,
   :var-type "function",
   :arglists ([engine debug]),
   :doc
   "Positional factory function for class cljs.repl.nashorn.NashornEnv.",
   :namespace "cljs.repl.nashorn",
   :wiki-url "/cljs.repl-api.html#cljs.repl.nashorn/->NashornEnv"}
  {:raw-source-url nil,
   :name "eval-resource",
   :file "src/main/clojure/cljs/repl/nashorn.clj",
   :source-url nil,
   :line 48,
   :var-type "function",
   :arglists ([engine path debug]),
   :doc "Evaluate a file on the classpath in the engine.",
   :namespace "cljs.repl.nashorn",
   :wiki-url "/cljs.repl-api.html#cljs.repl.nashorn/eval-resource"}
  {:raw-source-url nil,
   :name "map->NashornEnv",
   :file "src/main/clojure/cljs/repl/nashorn.clj",
   :source-url nil,
   :line 109,
   :var-type "function",
   :arglists ([m#]),
   :doc
   "Factory function for class cljs.repl.nashorn.NashornEnv, taking a map of keywords to field values.",
   :namespace "cljs.repl.nashorn",
   :wiki-url "/cljs.repl-api.html#cljs.repl.nashorn/map->NashornEnv"}
  {:raw-source-url nil,
   :name "repl-env",
   :file "src/main/clojure/cljs/repl/nashorn.clj",
   :source-url nil,
   :line 177,
   :var-type "function",
   :arglists ([& {:as opts}]),
   :doc
   "Create a Nashorn repl-env for use with the repl/repl* method in Clojurescript.",
   :namespace "cljs.repl.nashorn",
   :wiki-url "/cljs.repl-api.html#cljs.repl.nashorn/repl-env"}
  {:name "NashornEnv",
   :var-type "record",
   :namespace "cljs.repl.nashorn",
   :arglists nil,
   :wiki-url "/cljs.repl-api.html#cljs.repl.nashorn/NashornEnv",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "->NodeEnv",
   :file "src/main/clojure/cljs/repl/node.clj",
   :source-url nil,
   :line 192,
   :var-type "function",
   :arglists ([host port socket proc]),
   :doc
   "Positional factory function for class cljs.repl.node.NodeEnv.",
   :namespace "cljs.repl.node",
   :wiki-url "/cljs.repl-api.html#cljs.repl.node/->NodeEnv"}
  {:raw-source-url nil,
   :name "load-javascript",
   :file "src/main/clojure/cljs/repl/node.clj",
   :source-url nil,
   :line 69,
   :var-type "function",
   :arglists ([repl-env provides url]),
   :doc "Load a Closure JavaScript file into the Node REPL process.",
   :namespace "cljs.repl.node",
   :wiki-url "/cljs.repl-api.html#cljs.repl.node/load-javascript"}
  {:raw-source-url nil,
   :name "map->NodeEnv",
   :file "src/main/clojure/cljs/repl/node.clj",
   :source-url nil,
   :line 192,
   :var-type "function",
   :arglists ([m#]),
   :doc
   "Factory function for class cljs.repl.node.NodeEnv, taking a map of keywords to field values.",
   :namespace "cljs.repl.node",
   :wiki-url "/cljs.repl-api.html#cljs.repl.node/map->NodeEnv"}
  {:raw-source-url nil,
   :name "node-eval",
   :file "src/main/clojure/cljs/repl/node.clj",
   :source-url nil,
   :line 52,
   :var-type "function",
   :arglists ([repl-env js]),
   :doc "Evaluate a JavaScript string in the Node REPL process.",
   :namespace "cljs.repl.node",
   :wiki-url "/cljs.repl-api.html#cljs.repl.node/node-eval"}
  {:raw-source-url nil,
   :name "repl-env",
   :file "src/main/clojure/cljs/repl/node.clj",
   :source-url nil,
   :line 220,
   :var-type "function",
   :arglists ([& {:as options}]),
   :doc
   "Construct a Node.js evalution environment. Can supply :host and :port.",
   :namespace "cljs.repl.node",
   :wiki-url "/cljs.repl-api.html#cljs.repl.node/repl-env"}
  {:name "NodeEnv",
   :var-type "record",
   :namespace "cljs.repl.node",
   :arglists nil,
   :wiki-url "/cljs.repl-api.html#cljs.repl.node/NodeEnv",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "parse-param",
   :file "src/main/clojure/cljs/repl/reflect.clj",
   :source-url nil,
   :line 44,
   :var-type "function",
   :arglists ([path]),
   :doc
   "Parses the query parameter of a path of the form \"/reflect?var=foo\"\ninto the vector [\"var\" \"foo\"].",
   :namespace "cljs.repl.reflect",
   :wiki-url "/cljs.repl-api.html#cljs.repl.reflect/parse-param"}
  {:raw-source-url nil,
   :name "->RhinoEnv",
   :file "src/main/clojure/cljs/repl/rhino.clj",
   :source-url nil,
   :line 173,
   :var-type "function",
   :arglists ([]),
   :doc
   "Positional factory function for class cljs.repl.rhino.RhinoEnv.",
   :namespace "cljs.repl.rhino",
   :wiki-url "/cljs.repl-api.html#cljs.repl.rhino/->RhinoEnv"}
  {:raw-source-url nil,
   :name "load-file",
   :file "src/main/clojure/cljs/repl/rhino.clj",
   :source-url nil,
   :line 89,
   :var-type "function",
   :arglists ([repl-env opts src]),
   :doc
   "Load a JavaScript. This is needed to load JavaScript files before the Rhino\nenvironment is bootstrapped. After bootstrapping load-javascript will be\nused.",
   :namespace "cljs.repl.rhino",
   :wiki-url "/cljs.repl-api.html#cljs.repl.rhino/load-file"}
  {:raw-source-url nil,
   :name "map->RhinoEnv",
   :file "src/main/clojure/cljs/repl/rhino.clj",
   :source-url nil,
   :line 173,
   :var-type "function",
   :arglists ([m#]),
   :doc
   "Factory function for class cljs.repl.rhino.RhinoEnv, taking a map of keywords to field values.",
   :namespace "cljs.repl.rhino",
   :wiki-url "/cljs.repl-api.html#cljs.repl.rhino/map->RhinoEnv"}
  {:raw-source-url nil,
   :name "repl-env",
   :file "src/main/clojure/cljs/repl/rhino.clj",
   :source-url nil,
   :line 212,
   :var-type "function",
   :arglists ([& {:as opts}]),
   :doc
   "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls.",
   :namespace "cljs.repl.rhino",
   :wiki-url "/cljs.repl-api.html#cljs.repl.rhino/repl-env"}
  {:name "RhinoEnv",
   :var-type "record",
   :namespace "cljs.repl.rhino",
   :arglists nil,
   :wiki-url "/cljs.repl-api.html#cljs.repl.rhino/RhinoEnv",
   :source-url nil,
   :raw-source-url nil,
   :file nil}
  {:raw-source-url nil,
   :name "connection",
   :file "src/main/clojure/cljs/repl/server.clj",
   :source-url nil,
   :line 10,
   :var-type "function",
   :arglists ([]),
   :doc
   "Promise to return a connection when one is available. If a\nconnection is not available, store the promise in server/state.",
   :namespace "cljs.repl.server",
   :wiki-url "/cljs.repl-api.html#cljs.repl.server/connection"}
  {:raw-source-url nil,
   :name "dispatch-on",
   :file "src/main/clojure/cljs/repl/server.clj",
   :source-url nil,
   :line 41,
   :var-type "function",
   :arglists ([method pred handler] [method {:as m}]),
   :doc
   "Registers a handler to be dispatched based on a request method and a\npredicate.\n\npred should be a function that accepts an options map, a connection,\nand a request map and returns a boolean value based on whether or not\nthat request should be dispatched to the related handler.",
   :namespace "cljs.repl.server",
   :wiki-url "/cljs.repl-api.html#cljs.repl.server/dispatch-on"}
  {:raw-source-url nil,
   :name "parse-headers",
   :file "src/main/clojure/cljs/repl/server.clj",
   :source-url nil,
   :line 56,
   :var-type "function",
   :arglists ([header-lines]),
   :doc "Parse the headers of an HTTP POST request.",
   :namespace "cljs.repl.server",
   :wiki-url "/cljs.repl-api.html#cljs.repl.server/parse-headers"}
  {:raw-source-url nil,
   :name "send-and-close",
   :file "src/main/clojure/cljs/repl/server.clj",
   :source-url nil,
   :line 106,
   :var-type "function",
   :arglists
   ([conn status form]
    [conn status form content-type]
    [conn status form content-type encoding]),
   :doc
   "Use the passed connection to send a form to the browser. Send a\nproper HTTP response.",
   :namespace "cljs.repl.server",
   :wiki-url "/cljs.repl-api.html#cljs.repl.server/send-and-close"}
  {:raw-source-url nil,
   :name "set-connection",
   :file "src/main/clojure/cljs/repl/server.clj",
   :source-url nil,
   :line 24,
   :var-type "function",
   :arglists ([conn]),
   :doc
   "Given a new available connection, either use it to deliver the\nconnection which was promised or store the connection for later\nuse.",
   :namespace "cljs.repl.server",
   :wiki-url "/cljs.repl-api.html#cljs.repl.server/set-connection"}
  {:raw-source-url nil,
   :name "start",
   :file "src/main/clojure/cljs/repl/server.clj",
   :source-url nil,
   :line 170,
   :var-type "function",
   :arglists ([opts]),
   :doc "Start the server on the specified port.",
   :namespace "cljs.repl.server",
   :wiki-url "/cljs.repl-api.html#cljs.repl.server/start"}
  {:raw-source-url nil,
   :name "delay",
   :file "src/main/cljs/cljs/spec/impl/gen.cljc",
   :source-url nil,
   :line 32,
   :var-type "macro",
   :arglists ([& body]),
   :doc
   "given body that returns a generator, returns a\ngenerator that delegates to that, but delays\ncreation until used.",
   :namespace "cljs.spec.impl.gen",
   :wiki-url "/cljs.spec-api.html#cljs.spec.impl.gen/delay"}
  {:raw-source-url nil,
   :name "run-all-tests",
   :file "src/main/cljs/cljs/spec/test.cljc",
   :source-url nil,
   :line 26,
   :var-type "macro",
   :arglists ([]),
   :doc
   "Like clojure.test/run-all-tests, but runs test.check tests\nfor all speced vars. Prints per-test results to *out*, and\nreturns a map with :test,:pass,:fail, and :error counts.",
   :namespace "cljs.spec.test",
   :wiki-url "/cljs.spec-api.html#cljs.spec.test/run-all-tests"}
  {:raw-source-url nil,
   :name "run-tests",
   :file "src/main/cljs/cljs/spec/test.cljc",
   :source-url nil,
   :line 15,
   :var-type "macro",
   :arglists ([] [& ns-syms]),
   :doc
   "Like run-all-tests, but scoped to specific namespaces, or to\n*ns* if no ns-sym are specified.",
   :namespace "cljs.spec.test",
   :wiki-url "/cljs.spec-api.html#cljs.spec.test/run-tests"})}
